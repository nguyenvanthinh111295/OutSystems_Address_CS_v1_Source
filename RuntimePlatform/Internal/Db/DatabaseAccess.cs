/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading;
using System.Web;
using OutSystems.HubEdition.Extensibility.Data;
using OutSystems.HubEdition.Extensibility.Data.ConfigurationService;
using OutSystems.HubEdition.Extensibility.Data.Platform;
using OutSystems.HubEdition.Extensibility.Data.TransactionService;
using OutSystems.HubEdition.RuntimePlatform;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.Log;
using OutSystems.RuntimeCommon.ObfuscationProperties;
using System.Collections.Concurrent;

namespace OutSystems.Internal.Db {

    /// <summary>
    /// Class intended for OutSystems use only! Provides easy access to the database for different runtime configurations (CurrentEspace, DBConnection, System Database and Particular Database)
    /// </summary>
    public class DatabaseAccess {

        private const string SINGLETON_CONTEXT = "DatabaseAccess";

        #region Singleton override delegates
        public delegate DatabaseAccess SingletonGetterDelegate();
        public delegate void SingletonSetterDelegate(DatabaseAccess databaseAccess);
        #endregion

        #region Static fields

        protected static volatile DatabaseAccess singleton;

        private static volatile SingletonGetterDelegate GetSingletonOverride;
        private static volatile SingletonSetterDelegate SetSingletonOverride;

        private static readonly object locker = new object();

        private const int UninitializedQueryTimeout = -1;
        private static volatile int queryTimeout = UninitializedQueryTimeout;
        private static volatile int introspectionQueryTimeout = UninitializedQueryTimeout;

        private static int queryThreshold;
        private static volatile bool isQueryThresholdLoaded;
        private static bool isQueryThresholdLoading;
        private static readonly object queryThresholdLockObject = new object();

        private static volatile DatabasePluginProvider<IDatabaseProvider> integrationDatabasesPluginProvider;
        private static volatile DatabasePluginProvider<IPlatformDatabaseProvider> platformDatabasePluginProvider;

        private static DatabasePluginProvider<IDatabaseProvider> IntegrationDatabasesPluginProvider {
            get {
                if (integrationDatabasesPluginProvider == null) {
                    var pluginPath = GetPluginPaths().ToArray();
                    lock (typeof(DatabaseAccess)) {
                        if (integrationDatabasesPluginProvider == null) {
                            integrationDatabasesPluginProvider = new DatabasePluginProvider<IDatabaseProvider>(pluginPath);
                        }
                    }
                }
                return integrationDatabasesPluginProvider;
            }
        }

        private static DatabasePluginProvider<IPlatformDatabaseProvider> PlatformDatabasePluginProvider {
            get {
                if (platformDatabasePluginProvider == null) {
                    var pluginPath = GetPluginPaths().ToArray();
                    lock (typeof(DatabaseAccess)) {
                        if (platformDatabasePluginProvider == null) {
                            platformDatabasePluginProvider = new DatabasePluginProvider<IPlatformDatabaseProvider>(pluginPath);
                        }
                    }
                }
                return platformDatabasePluginProvider;
            }
        }

        #endregion

        #region Instance fields

        private readonly IDictionary<string, ITransactionManager> sharedTransactionManagers = new Dictionary<string, ITransactionManager>();

        /// <summary>
        /// The systemProvider is the one used by the application to access the OutSystems database
        /// </summary>
        private DatabaseAccessProvider<IPlatformDatabaseServices> systemProvider;

        /// <summary>
        /// The DatabaseProviders dictionary stores all connections that are used to access different databases
        /// </summary>
        private readonly IDictionary<string, DatabaseAccessProvider<IPlatformDatabaseServices>> databaseProviders
            = new Dictionary<string, DatabaseAccessProvider<IPlatformDatabaseServices>>();

        /// <summary>
        /// The dbConnectionProviders dictionary stores all external database connections
        /// </summary>
        private volatile IDictionary<string, DatabaseAccessProvider<IDatabaseServices>> dbConnectionProviders
            = new Dictionary<string, DatabaseAccessProvider<IDatabaseServices>>();

        private readonly DatabaseAccessProvider<IPlatformDatabaseServices> sessionProvider;
        private readonly DatabaseAccessProvider<IPlatformDatabaseServices> loggingProvider;

        #endregion

        private DatabaseAccessProvider<IPlatformDatabaseServices> GetRuntimeProviderForDatabase(
                IRuntimeDatabaseConfiguration runtimeDatabaseConfiguration) {

            return GetProviderForDatabase(runtimeDatabaseConfiguration, DatabaseSettingsSerialization.User.Runtime, SystemProvider, databaseProviders,
                sharedTransactionManagers);
        }

        #region Constructors
        /// <summary>
        /// Create a new instance of the <see cref="DatabaseAccess"/> class.
        /// </summary>
        protected DatabaseAccess() : this(/*initialize*/false) { } // Used By PlatformDatabaseAcesss

        /// <summary>
        /// Create a new instance of the <see cref="DatabaseAccess"/> class using the given <c>IDatabaseServices</c>.
        /// </summary>
        /// <param name="initialize">True to initialize the providers, false otherwise</param>
        private DatabaseAccess(bool initialize) {
            if (initialize) {
                var source = AccessRequester;

                systemProvider = CreatePlatformDatabaseAccessProvider(source, DatabaseSettingsSerialization.User.Runtime);
                sessionProvider = CreatePlatformDatabaseAccessProvider(source, DatabaseSettingsSerialization.User.Session);
                loggingProvider = CreatePlatformDatabaseAccessProvider(source, DatabaseSettingsSerialization.User.Log);
            }
        }

        #endregion

        #region Singleton
        /// <summary>
        /// Gets the current DatabaseAccess. 
        /// If inside a web application, fetchs it from the request. Otherwise, it returns a static one.
        /// </summary>
        internal static DatabaseAccess Current {
            [DoNotObfuscate]
            get {
                CheckAccess("Current");
                HttpContext context = HttpContext.Current;


                if (context == null) {
                    if (GetSingletonOverride == null) {
                        if (singleton == null) {
                            var access = new DatabaseAccess(/*initialize*/true);
                            lock (locker) {
                                if (singleton == null) {
                                    singleton = access;
                                }
                            }
                        }
                        return singleton;
                    } else {
                        if (GetSingletonOverride() == null) {
                            var access = new DatabaseAccess(/*initialize*/true);
                            lock (locker) {
                                if (GetSingletonOverride() == null) {
                                    SetSingletonOverride(access);
                                }
                            }
                            
                        }
                        return GetSingletonOverride();
                    }
                } else {

                    if (context.Items[SINGLETON_CONTEXT] == null) {
                        var access = new DatabaseAccess(/*initialize*/true);
                        lock (context) {
                            if (context.Items[SINGLETON_CONTEXT] == null) {
                                context.Items[SINGLETON_CONTEXT] = access;
                            }
                        }
                    }
                    return (DatabaseAccess)context.Items[SINGLETON_CONTEXT];
                }
            }
        }

        /// <summary>
        /// The plugin provider that is used to create the integration database services
        /// </summary>
        public static DatabasePluginProvider<IDatabaseProvider> CurrentIntegrationDatabasesPluginProvider {
            get {
                return IntegrationDatabasesPluginProvider;
            }
        }

        public static DatabasePluginProvider<IPlatformDatabaseProvider> CurrentPlatformDatabasesPluginProvider {
            get {
                return PlatformDatabasePluginProvider;
            }
        }

        /// <summary>
        /// Indicates if the underlying database access objects are initialized and this class is ready to be used
        /// </summary>
        /// <returns><c>true</c> if it is initialized, otherwise <c>false</c>.</returns>
        internal static bool IsInitialized() {
            HttpContext context = HttpContext.Current;
            return context.Items[SINGLETON_CONTEXT] != null;
        }

        /// <summary>
        /// Overrides the current DatabaseAccess with a custom provider.
        /// </summary>
        /// <param name="getOverride">The new getter.</param>
        /// <param name="setOverride">The new setter.</param>
        public static void SingletonOverride(SingletonGetterDelegate getOverride, SingletonSetterDelegate setOverride) {
            lock (locker) {
                GetSingletonOverride = getOverride;
                SetSingletonOverride = setOverride;
            }
        }
        #endregion

        #region Public API

        /// <summary>
        /// Gets a provider for the main database associated with the currently running application.
        /// This should be used to access data that is managed by this or other applications that share the same database.
        /// </summary>
        /// <value>The <c>DatabaseAccessProvider</c> used to acces the main database.</value>
        public static DatabaseAccessProvider<IPlatformDatabaseServices> ForCurrentDatabase {
            get { return Current.MainProvider; }
        }

        /// <summary>
        /// Gets a provider for the system database.
        /// This should be used to access data that is managed by the platform.
        /// </summary>
        /// <value>The <c>DatabaseAccessProvider</c> used to acces the system database.</value>
        public static DatabaseAccessProvider<IPlatformDatabaseServices> ForSystemDatabase {
            get { return Current.SystemProvider; }
        }

        /// <summary>
        /// Gets a provider for a specific eSpace database.
        /// This should be used to access data that is managed by that specific eSpace.
        /// </summary>
        /// <param name="eSpaceId">eSpace identifier.</param>
        /// <returns>The <c>DatabaseAccessProvider</c> to access the given database.</returns>
        public static DatabaseAccessProvider<IPlatformDatabaseServices> ForEspaceDatabase(int eSpaceId) {
            return Current.GetEspaceDatabaseProvider(eSpaceId);
        }

        /// <summary>
        /// Gets a provider for a specific database.
        /// This should be used to access data that is managed by applications that are configured to use this database.
        /// </summary>
        /// <param name="databaseName">Name of the database.</param>
        /// <returns>The <c>DatabaseAccessProvider</c> to access the given database.</returns>
        public static DatabaseAccessProvider<IPlatformDatabaseServices> ForDatabase(string databaseName) {
            return Current.GetDatabaseProvider(databaseName);
        }

        /// <summary>
        /// Gets a provider for a specific external database connection.
        /// This should be used to access data that is managed by external systems that use this connection.
        /// </summary>
        /// <param name="connectionName">Name of the external database connection.</param>
        /// <returns>The <c>DatabaseAccessProvider</c> based on the given connection.</returns>
        public static DatabaseAccessProvider<IDatabaseServices> ForDBConnection(string connectionName) {
            return Current.GetDBConnectionProvider(connectionName);
        }

        public static DatabaseAccessProvider<IPlatformDatabaseServices> ForSession {
            get { return Current.SessionProvider; }
        }

        public static DatabaseAccessProvider<IPlatformDatabaseServices> ForLogging {
            get { return Current.LoggingProvider; }
        }

        /// <summary>
        /// Creates a new unmanaged connection using a custom configuration.
        /// </summary>
        /// <param name="config">Database configuration.</param>
        /// <returns>An instance of a <c>DatabaseConnection</c> using the given configuration.</returns>
        public static DatabaseConnection CreateConnection(IRuntimeDatabaseConfiguration config) {
            IDatabaseServices databaseServices = config.DatabaseProvider.GetIntegrationDatabaseServices(config);
            return new DatabaseConnection(databaseServices, databaseServices.TransactionService.CreateConnection());
        }

        /// <summary>
        /// Commits all transactions (main transactions only).
        /// </summary>
        public static void CommitAllTransactions() {
            Current.InnerCommitAllTransactions();
        }

        /// <summary>
        /// Rolls back all transactions (main transactions only).
        /// </summary>
        public static void RollbackAllTransactions() {
            Current.InnerRollbackAllTransactions();
        }

        /// <summary>
        /// Releases all transactions (pooled and main), commiting or rollingback depending on the
        /// the value of "commit".
        /// </summary>
        /// <param name="commit">True to commit the transactions, false to rollback.</param>
        public static void FreeupResources(bool commit) {
            if (IsInitialized()) {
                Current.InnerFreeupResources(commit);
            }
        }

        /// <summary>
        /// Resets the current DatabaseAccess configuration.
        /// NOTE: this method frees up any resources that may still be allocated.
        /// </summary>
        public static void ResetConfiguration() {
            if (IsInitialized()) {
                DatabaseAccess current = Current;
                // Free up resources of existing connection manager
                if (current.MainProvider != null) {
                    current.InnerFreeupResources(false);
                }

                current.SystemProvider = CreatePlatformDatabaseAccessProvider(
                    AccessRequester,
                    DatabaseSettingsSerialization.User.Runtime);
            }
        }

        /// <summary>
        /// Finds the correct DatabaseAccessProvider for an unmanaged transaction object.
        /// </summary>
        /// <param name="trans">Unmanaged transaction.</param>
        /// <returns>The <c>DatabaseAccessProvider</c> based on the given trasaction.</returns>
        public static IDatabaseAccessProvider GetProviderForTransaction(IDbTransaction trans) {
            IDatabaseAccessProvider provider;
            TryGetProviderForTransaction(trans, out provider);
            return provider;
        }

        /// <summary>
        /// Finds the correct DatabaseAccessProvider for an unmanaged transaction object, belonging to a particular database.
        /// </summary>
        /// <param name="trans">The unmanaged transaction.</param>
        /// <param name="database"></param>
        /// <returns>The <c>DatabaseAccessProvider</c> based on the given trasaction to access the given database.</returns>
        public static IDatabaseAccessProvider GetProviderForTransaction(IDbTransaction trans, string database) {
            IDatabaseAccessProvider provider;
            TryGetProviderForTransaction(trans, database, out provider);
            return provider;
        }

        /// <summary>
        /// Disable transaction commits for the remaining duration of the current request
        /// NOTE: Leaving this setting set to true will affect all future commit. It should only be changed
        /// inside a 'try .. finally' block, making sure it is set to false in the end.
        /// </summary>
        /// <value><c>true</c> if commits are disabled otherwise, <c>false</c>.</value>
        public static bool DisableCommits { get; set; }

        /// <summary>
        /// Blocks all access to the database while the value is true
        /// NOTE: Leaving this setting set to true will affect all future commit. It should only be changed
        /// inside a 'try .. finally' block, making sure it is set to false in the end
        /// </summary>
        /// <value><c>true</c> if the access to the batabase is blocked otherwise, <c>false</c>.</value>
        public static bool BlockAccess { get; set; }
        #endregion

        #region API implementation

        private static DatabaseSettingsSerialization.Source AccessRequester {
            get {
                return HttpContext.Current == null
                    ? DatabaseSettingsSerialization.Source.Services
                    : DatabaseSettingsSerialization.Source.Application;
            }
        }

        /// <summary>
        /// The DatabaseAccessProvider responsible for connecting to the OutSystems system database.
        /// </summary>
        /// <value>The <c>DatabaseAccessProvider</c> to the system database.</value>
        protected internal virtual DatabaseAccessProvider<IPlatformDatabaseServices> SystemProvider {
            get {
                return systemProvider;
            }
            [DoNotObfuscate] // This is called using reflection in tests
            private set {
                systemProvider = value;
            }
        }

        /// <summary>
        /// The DatabaseAccessProvider responsible for connecting to the current main database (that can be the system database) in the the OutSystems database server
        /// </summary>
        /// <value>The <c>DatabaseAccessProvider</c> to the main database.</value>
        protected internal virtual DatabaseAccessProvider<IPlatformDatabaseServices> MainProvider {
            get {
                return GetRuntimeProviderForDatabase(ConfigurationForCurrentMain());
            }
        }

        /// <summary>
        /// The DatabaseAccessProvider responsible for connecting to a specific eSpace's database in the the OutSystems database server
        /// </summary>
        /// <param name="eSpaceId">eSpace identifier.</param>
        /// <returns>An object to access the database</returns>
        protected internal virtual DatabaseAccessProvider<IPlatformDatabaseServices> GetEspaceDatabaseProvider(int eSpaceId) {
            return GetRuntimeProviderForDatabase(ConfigurationForESpace(eSpaceId));
        }

        /// <summary>
        /// The DatabaseAccessProvider responsible for connecting to a specific database in the the OutSystems database server
        /// </summary>
        /// <param name="databaseName">Name of the database.</param>
        /// <returns>An object to access the database</returns>
        protected internal virtual DatabaseAccessProvider<IPlatformDatabaseServices> GetDatabaseProvider(string databaseName) {
            return GetRuntimeProviderForDatabase(ConfigurationForDatabase(databaseName, DatabaseSettingsSerialization.User.Runtime));
        }

        /// <summary>
        /// The DatabaseAccessProvider responsible for connecting to a specific external database connection
        /// </summary>
        /// <param name="connectionName">Name of the connection.</param>
        /// <returns>An object to access the database</returns>
        protected internal virtual DatabaseAccessProvider<IDatabaseServices> GetDBConnectionProvider(string connectionName) {
            connectionName = connectionName.ToUpperInvariant();
            DatabaseAccessProvider<IDatabaseServices> provider;
            if (!dbConnectionProviders.TryGetValue(connectionName, out provider)) {
                lock (dbConnectionProviders) {
                    if (!dbConnectionProviders.TryGetValue(connectionName, out provider)) {
                        ITransactionManager transactionManager = GetTransactionManager(connectionName);
                        provider = new DatabaseAccessProvider<IDatabaseServices>(transactionManager.TransactionService.DatabaseServices, transactionManager);
                        dbConnectionProviders.Add(connectionName, provider);
                    }
                }
            }
            return provider;
        }

        /// <summary>
        /// Gets the transaction manager.
        /// </summary>
        /// <param name="connectionName">Name of the connection.</param>
        /// <returns>An instance of a <c>ITransactionManager</c> for the given connection.</returns>
        internal static ITransactionManager GetTransactionManager(string connectionName) {

            IRuntimeDatabaseConfiguration configuration = null;
            if (HttpContext.Current != null) { //because this can be needed outside webapplications (ex: unit tests)
                AppInfo info = AppInfo.GetAppInfo();
                int eSpaceId = info.eSpaceId;
                //TODO DVN: sandbox - external database connections aren't supported because connection info is cached
                var integrationConfiguration =
                    AppCache.GetESpaceCachedValue<string, IIntegrationDatabaseConfiguration>(connectionName,
                        "DatabaseServicesCache" + eSpaceId,
                        eSpaceId,
                        InnerGetDatabaseConfigurationByConnectionName);

                if (info.PlatformExtensibilityAPIsEnabled) {
                    Pair<String, String> connectionStringOverride = info.OsContext.Session.GetDatabaseConnectionOverride(connectionName);
                    if (connectionStringOverride != null && !connectionStringOverride.First.IsEmpty()) {

                        var helper =
                            integrationConfiguration.DatabaseProvider.GetProviderSpecificOrBaseType<DatabaseConfigurationHelper>(
                                DatabaseConfigurationHelper.ProviderSpecificTypes);
                        configuration = helper.ChangeConnectionString(integrationConfiguration, connectionStringOverride.First,
                            connectionStringOverride.Second);
                    }
                }
                if (configuration == null) {
                    configuration = integrationConfiguration.RuntimeDatabaseConfiguration;
                }
            } else {
                configuration = InnerGetDatabaseConfigurationByConnectionName(connectionName).RuntimeDatabaseConfiguration;
            }
            var services = configuration.DatabaseProvider.GetIntegrationDatabaseServices(configuration);
            return services.TransactionService.CreateTransactionManager();
        }

        /// <summary>
        /// Gets database services for the given connection
        /// </summary>
        /// <param name="connectionName">Name of the connection.</param>
        /// <returns>An instance of a <c>IDatabaseServices</c> to the given connection.</returns>
        /// <exception cref="ConnectionNotFoundException"></exception>
        private static IIntegrationDatabaseConfiguration InnerGetDatabaseConfigurationByConnectionName(string connectionName) {
            using (Transaction trans = ForSystemDatabase.GetReadOnlyTransaction()) {
                string wrappedConfig = DBRuntimePlatform.Instance.GetDatabaseConfiguration(trans, connectionName);
                if (wrappedConfig.IsNullOrEmpty()) {
                    throw new ConnectionNotFoundException(String.Format("Failed to retrieve {0} connection details from Database.", connectionName));
                }
                return OutSystems.Internal.Db.Deserializers.ForIntegration(
                                        key =>
                                            CurrentIntegrationDatabasesPluginProvider
                                                .GetImplementation(key)
                                                .CreateEmptyIntegrationDatabaseConfiguration())
                                    .Deserialize(wrappedConfig);
            }
        }

        /// <summary>
        /// Commit all transactions.
        /// </summary>
        protected internal void InnerCommitAllTransactions() {
            if (DisableCommits) {
                return;
            }

            foreach (DatabaseAccessProvider<IDatabaseServices> dbConnectionProvider in dbConnectionProviders.Values) {
                dbConnectionProvider.CommitAllTransactions();
            }

            foreach (DatabaseAccessProvider<IPlatformDatabaseServices> dbProvider in databaseProviders.Values) {
                dbProvider.CommitAllTransactions();
            }

            SystemProvider.CommitAllTransactions();
        }

        /// <summary>
        /// Roll back all transactions.
        /// </summary>
        protected internal void InnerRollbackAllTransactions() {
            foreach (DatabaseAccessProvider<IDatabaseServices> dbConnectionProvider in dbConnectionProviders.Values) {
                dbConnectionProvider.RollbackAllTransactions();
            }

            foreach (DatabaseAccessProvider<IPlatformDatabaseServices> dbProvider in databaseProviders.Values) {
                dbProvider.RollbackAllTransactions();
            }

            SystemProvider.RollbackAllTransactions();
        }

        /// <summary>
        /// Freeup resources.
        /// </summary>
        /// <param name="commit">If set to <c>true</c> the transactions will be committed.</param>
        /// <exception cref="TransactionException">Exception launched to when an error occurs trying to close the transaction.</exception>
        [DoNotObfuscate]
        protected internal void InnerFreeupResources(bool commit) {
            string errorMessage = "";
            Exception lastException = null;

            foreach (IDatabaseAccessProvider provider in
                dbConnectionProviders.Values.Cast<IDatabaseAccessProvider>().Concat(databaseProviders.Values.Cast<IDatabaseAccessProvider>())) {
                try {
                    provider.FreeupResources(commit);
                } catch (Exception e) {
                    commit = false;
                    lastException = e;
                    string error = String.Format("Error closing the transaction to the database: {0}\n{1}\n{2}", e.Message, e.StackTrace, new StackTrace(true));
                    
                    EventLogger.WriteError(error);
                    errorMessage = String.Format("{0}\n{1}", errorMessage, error);
                }
            }

            try {
                SystemProvider.FreeupResources(commit);
            } catch (Exception e) {
                lastException = e;
                string error = String.Format("Error closing the transaction to the database: {0}\n{1}\n{2}", e.Message, e.StackTrace, new StackTrace(true));
                
                EventLogger.WriteError(error);
                errorMessage = String.Format("{0}\n{1}", errorMessage, error);
            }

            if (errorMessage != "") {
                throw new TransactionException(errorMessage, lastException);
            }
        }
        #endregion

        #region Compatibility stuff

        /// <summary>
        /// Tries to get a database access based on the given transaction.
        /// </summary>
        /// <param name="trans">The transaction.</param>
        /// <param name="provider">The object to access the database.</param>
        /// <returns><c>true</c> if the <c>DatabaseAccessProvider</c> could be created, <c>false</c> otherwise.</returns>
        internal static bool TryGetProviderForTransaction(IDbTransaction trans, out IDatabaseAccessProvider provider) {
            string databaseName;

            
            databaseName = trans.Connection.Database.ToUpperInvariant();
            return TryGetProviderForTransaction(trans, databaseName, out provider);
        }

        /// <summary>
        /// Tries to get a database access based on the given transaction.
        /// </summary>
        /// <param name="trans">The transaction.</param>
        /// <param name="databaseName">Name of database to connect to.</param>
        /// <param name="provider">The object to access the database.</param>
        /// <returns><c>true</c> if the <c>DatabaseAccessProvider</c> could be created, <c>false</c> otherwise.</returns>
        internal static bool TryGetProviderForTransaction(IDbTransaction trans, string databaseName, out IDatabaseAccessProvider provider) {
            provider = Current.InnerGetProviderForTransaction(trans, databaseName);
            if (provider != null) {
                return true;
            }
            provider = ForSystemDatabase;
            return false;
        }

        /// <summary>
        /// Tries to get a database access based on the given transaction for the database identifier.
        /// </summary>
        /// <param name="trans">The transaction.</param>
        /// <param name="databaseName">Name of database to connect to.</param>
        /// <returns>A database access to the given database identifier.</returns>
        protected internal IDatabaseAccessProvider InnerGetProviderForTransaction(IDbTransaction trans, string databaseName) {
            if (trans != null && trans.Connection != null) {
                DatabaseAccessProvider<IPlatformDatabaseServices> provider;
                if (databaseProviders.TryGetValue(databaseName, out provider)) {
                    return provider;
                }
                if (SystemProvider.DatabaseServices.DatabaseConfiguration.DatabaseIdentifier.EqualsIgnoreCase(databaseName)
                        && SystemProvider.TransactionManager.IsManaging(trans)) {

                    return SystemProvider;
                }
                foreach (var dbConnectionProvider in dbConnectionProviders.Values) {
                    if (dbConnectionProvider.TransactionManager.IsManaging(trans)) {
                        return dbConnectionProvider;
                    }
                }
            }

            return null;
        }

        protected internal static IRuntimeDatabaseConfiguration ConfigurationForDatabase(string databaseName, DatabaseSettingsSerialization.User user) {
            return ConfigurationForDatabase(databaseName, AccessRequester, user);
        }

        protected internal static IRuntimeDatabaseConfiguration ConfigurationForDatabase(string databaseName, DatabaseSettingsSerialization.Source source, DatabaseSettingsSerialization.User user) {
            if (string.IsNullOrEmpty(databaseName)
                || (databaseName == Constants.SystemDatabaseLogicalName)
                || (databaseName == ForSystemDatabase.DatabaseServices.DatabaseConfiguration.DatabaseIdentifier)) {
                return null;
            }

            using (var trans = ForSystemDatabase.GetCommitableTransaction()) {
                var eSpaceParams = DBRuntimePlatform.Instance.GetCatalogDetailsByName(trans, databaseName, user);
                if (eSpaceParams == null) {
                    return null;
                }

                var baseConf = RuntimeDatabaseConfigurations.For(
                    CurrentPlatformDatabasesPluginProvider,
                    source,
                    user);

                baseConf.SetParameters(eSpaceParams);
                return baseConf;
            }
        }

        protected internal static IRuntimeDatabaseConfiguration ConfigurationForESpace(int eSpaceId) {
            return AppCache.GetESpaceCachedValue<IRuntimeDatabaseConfiguration>("DBPackCache" + eSpaceId,
                                                                                  eSpaceId,
                                                                                  LoadConfigurationForESpace);
        }

        protected internal static IRuntimeDatabaseConfiguration LoadConfigurationForESpace(int eSpaceId) {
            using (var trans = ForSystemDatabase.GetCommitableTransaction()) {
                var details = DBRuntimePlatform.Instance.GetCatalogDetailsByESpaceId(trans, eSpaceId);

                if (details == null) {
                    return null;
                }

                var conf = RuntimeDatabaseConfigurations.For(
                    PlatformDatabasePluginProvider,
                    AccessRequester,
                    DatabaseSettingsSerialization.User.Runtime);

                conf.SetParameters(details);

                return conf;
            }
        }

        private static IRuntimeDatabaseConfiguration ConfigurationForCurrentMain() {
            HttpContext context = HttpContext.Current;
            if (context != null) {
                AppInfo app;
                try {
                    app = AppInfo.GetAppInfo(context);
                } catch (LicensingException) {
                    return null; // Fallback to the System Catalog
                }
                if (app != null) {
                    return ConfigurationForESpace(app.OsContext.CurrentESpaceId);
                }
            }
            return null;
        }
        #endregion

        #region Utilities

        protected static DatabaseAccessProvider<IPlatformDatabaseServices> GetProviderForDatabase(IRuntimeDatabaseConfiguration configurationForDatabase,
                DatabaseSettingsSerialization.User user, DatabaseAccessProvider<IPlatformDatabaseServices> systemDatabaseProvider,
                IDictionary<string, DatabaseAccessProvider<IPlatformDatabaseServices>> providersByIdentifier,
                IDictionary<string, ITransactionManager> transactionManagersByIdentifier) {

            if (configurationForDatabase == null) {
                return systemDatabaseProvider;
            }

            bool supportsUnifiedTransactionManager = (user == DatabaseSettingsSerialization.User.Admin)
                || Settings.GetBool(Settings.Configs.SupportUnifiedMDC);

            var systemConfig = systemDatabaseProvider.DatabaseServices.DatabaseConfiguration;

            string managerIdentifier = supportsUnifiedTransactionManager ?
                configurationForDatabase.Username
                : configurationForDatabase.DatabaseIdentifier;

            string systemManagerIdentifier = supportsUnifiedTransactionManager ?
                systemConfig.Username
                : systemConfig.DatabaseIdentifier;

            bool sameIdentifier = managerIdentifier.EqualsIgnoreCase(systemManagerIdentifier);
            // If using the system manager to access the system database, we can use the SystemProvider
            bool sameDatabase = configurationForDatabase.DatabaseIdentifier.EqualsIgnoreCase(systemConfig.DatabaseIdentifier);

            if (sameIdentifier && sameDatabase) {
                return systemDatabaseProvider;
            }

            // In unified MDC scenarios, we want to use a provider with a shared transaction manager 
            // while keeping the original configuration that uses the correct database identifier
            string providerIdentifier = managerIdentifier + (supportsUnifiedTransactionManager ? "-" + configurationForDatabase.DatabaseIdentifier : "");
            DatabaseAccessProvider<IPlatformDatabaseServices> provider;
            if (!providersByIdentifier.TryGetValue(providerIdentifier, out provider)) {
                lock (providersByIdentifier) {
                    if (!providersByIdentifier.TryGetValue(providerIdentifier, out provider)) {
                        ITransactionManager manager = sameIdentifier ? systemDatabaseProvider.TransactionManager : null;
                        if (manager == null && !transactionManagersByIdentifier.TryGetValue(managerIdentifier, out manager)) {
                            var services = PlatformDatabasePluginProvider
                                            .GetImplementation(configurationForDatabase.ProviderKey())
                                            .GetPlatformDatabaseServices(configurationForDatabase);
                            manager = services.TransactionService.CreateTransactionManager();
                            transactionManagersByIdentifier.Add(managerIdentifier, manager);
                        }

                        // TODO: Check with the Stack Team if we can optimized this
                        var dapServices = PlatformDatabasePluginProvider
                                            .GetImplementation(configurationForDatabase.ProviderKey())
                                            .GetPlatformDatabaseServices(configurationForDatabase);

                        dapServices.IntrospectionService.QueryTimeout = IntrospectionQueryTimeout;
                        provider = new DatabaseAccessProvider<IPlatformDatabaseServices>(
                                        dapServices,
                                        manager);

                        providersByIdentifier.Add(providerIdentifier, provider);
                    }
                }
            }
            return provider;
        }

        private static ConcurrentDictionary<Pair<DatabaseSettingsSerialization.Source, DatabaseSettingsSerialization.User>, IRuntimeDatabaseConfiguration> cachedPlatformAccessConfigurations = 
            new ConcurrentDictionary<Pair<DatabaseSettingsSerialization.Source, DatabaseSettingsSerialization.User>, IRuntimeDatabaseConfiguration>();

        protected static DatabaseAccessProvider<IPlatformDatabaseServices> CreatePlatformDatabaseAccessProvider(
                DatabaseSettingsSerialization.Source source,
                DatabaseSettingsSerialization.User user)
        {

            var pluginProvider = PlatformDatabasePluginProvider;

            var key = Pair.Create(source, user);
            IRuntimeDatabaseConfiguration conf;

            if (source == DatabaseSettingsSerialization.Source.Application) {
                // We don't use GetOrAdd because in Java computeIfAbsent holds a lock
                // while evaluating the factory function which can lead to deadlocks when one thread
                // is initializing the database access for the first time and another is retrieving 
                // a setting from the database
                if (!cachedPlatformAccessConfigurations.TryGetValue(key, out conf)) {
                    var newConf = RuntimeDatabaseConfigurations.For(pluginProvider, source, user);
                    conf = cachedPlatformAccessConfigurations.GetOrAdd(key, newConf);
                }
            } else {
                // Service Configurations can't be cached becase the underlining settings storage keeps changing as they serve diferent sandboxes
                conf = RuntimeDatabaseConfigurations.For(pluginProvider, source, user);
            }

            if (conf == null || conf.ConnectionString.IsEmpty()) {
                throw new InvalidOperationException("Unable to obtain the connection string. Please run Configuration Tool.");
            }

            var services = pluginProvider.GetImplementation(conf.ProviderKey()).GetPlatformDatabaseServices(conf);
            services.IntrospectionService.QueryTimeout = IntrospectionQueryTimeout;
            return new DatabaseAccessProvider<IPlatformDatabaseServices>(
                services,
                services.TransactionService.CreateTransactionManager());
        }

        private static IEnumerable<DirectoryInfo> GetPluginPaths() {
            if (HttpContext.Current == null) {
                string path = Path.Combine(Settings.Get(Settings.Configs.PluginDirectory), "database");
                DirectoryInfo dirFromSettings = new DirectoryInfo(path);
                if (dirFromSettings.Exists) {
                    yield return dirFromSettings;
                }
            }
#if !JAVA
            DirectoryInfo runtimePluginDir = new DirectoryInfo(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, RuntimePlatformUtils.GetLibDirectoryName()));
            if (runtimePluginDir.Exists) {
                yield return runtimePluginDir;
            }
#endif
        }

        /// <summary>
        /// Checks the access to the <c>DatabaseAccess</c>.
        /// </summary>
        /// <param name="name">The element name.</param>
        /// <exception cref="InvalidDatabaseAccessException">Blocked access when trying to to access 'DatabaseAccess. + name + '.</exception>
        private static void CheckAccess(string name) {
            if (BlockAccess) {
                throw new InvalidDatabaseAccessException("Blocked access when trying to to access 'DatabaseAccess." + name + "'.");
            }
        }
        #endregion

        #region Query Timeout
        /// <summary>
        /// Gets or sets the query timeout, in seconds.
        /// </summary>
        /// <value>The query timeout, in seconds.</value>
        public static int QueryTimeout {
            get {
                if (queryTimeout == UninitializedQueryTimeout) {
                    int timeoutValue;
                    if (!int.TryParse(Settings.Get(Settings.Configs.QueryTimeout), out timeoutValue)) {
                        timeoutValue = 30;
                    }
                    queryTimeout = timeoutValue;
                    return timeoutValue;
                }
                return queryTimeout;
            }
            set {
                queryTimeout = value;
            }
        }

        /// <summary>
        /// Gets or sets the query timeout, in seconds.
        /// </summary>
        /// <value>The query timeout, in seconds.</value>
        public static int IntrospectionQueryTimeout {
            get {
                if (introspectionQueryTimeout == UninitializedQueryTimeout) {
                    int timeoutValue;
                    if (!int.TryParse(Settings.Get(Settings.Configs.IntrospectionQueryTimeout), out timeoutValue)) {
                        timeoutValue = QueryTimeout;
                    }
                    introspectionQueryTimeout = timeoutValue;
                    return timeoutValue;
                }
                return introspectionQueryTimeout;
            }
            set {
                introspectionQueryTimeout = value;
            }
        }

        #endregion

        #region Slow Queries Logging
        // We shouldn't log slow queries in configuration tool:
        public static bool SkipSlowQueries { get; set; }

        // Queries that take more than "SlowQueryThreshold" miliseconds are logged in oslog_general as slow queries.
        internal static int SlowQueryThreshold {
            get {
                // must avoid loophole of Settings Getter wanting to know if it was a slow query
                // and calling this method again that will call the Settings Getter again and so on...
                if (!isQueryThresholdLoaded) {
                    lock (queryThresholdLockObject) {
                        if (!isQueryThresholdLoaded) {
                            if (isQueryThresholdLoading) {
                                return Int32.MaxValue;
                            }
                            isQueryThresholdLoading = true;
                            queryThreshold = Settings.GetInt(Settings.Configs.Log_SlowSQLThresholdInMs);
                            isQueryThresholdLoaded = true;
                        }
                    }
                }

                return queryThreshold;
            }
            set {
                queryThreshold = value;
            }
        }

        internal static void LogSlowQuery(DateTime logTime, string log) {
            if (SkipSlowQueries) {
                return;
            }

            string sessionid = "";
            int espaceid = 0, tenantid = 0, userid = 0;

            if (System.Web.HttpContext.Current != null) { // if inside a web application
                AppInfo.GetAppInfoInformation(out espaceid, out tenantid, out sessionid, out userid);
                // if this is a query to get AppInfo information -> do not log
                if (espaceid == 0) { return; }
            }

            var logger = new OutSystems.HubEdition.RuntimePlatform.Log.GeneralLog();
            logger.Write(logTime, sessionid, espaceid, tenantid, userid, log, OutSystems.HubEdition.RuntimePlatform.Log.GeneralLogType.WARNING.ToString(),
                "SLOWSQL", "");
        }
        #endregion


        protected internal DatabaseAccessProvider<IPlatformDatabaseServices> SessionProvider {
            get { return sessionProvider; }
        }

        protected internal DatabaseAccessProvider<IPlatformDatabaseServices> LoggingProvider {
            get { return loggingProvider; }
        }

        protected static void InvalidateCaches() {
            Current.sharedTransactionManagers.Clear();
            Current.databaseProviders.Clear();
            Current.dbConnectionProviders.Clear();
        }
    }

    /// <summary>
    /// Class that represents an exception that occurs due to an invalid access to a database.
    /// </summary>
    public class InvalidDatabaseAccessException : Exception {
        public InvalidDatabaseAccessException(string message) : base(message) { }
    }

    /// <summary>
    /// Exception that represents an error that occurs due to an external database connection configuration not found in the database.
    /// </summary>
    public class ConnectionNotFoundException : Exception {
        public ConnectionNotFoundException(string message) : base(message) { }
    }
}
