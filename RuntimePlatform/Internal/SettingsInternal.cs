/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Data;
using System.Security.AccessControl;
using Microsoft.Win32;
using OutSystems.HubEdition.Extensibility.Data.Platform;
using OutSystems.HubEdition.RuntimePlatform;
using OutSystems.Internal.Db;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.Log;
using OutSystems.RuntimeCommon.ObfuscationProperties;

// ReSharper disable once CheckNamespace
namespace OutSystems.Internal.RuntimePlatform {
    public class SettingsInternal {
        private const string osRegistryKey = "Software\\OutSystems";
        private const string settingSubKey = osRegistryKey + "\\Platform Server";
        private const string machineNameSetting = "MachineName";
        private const string serialSetting = "SerialNumber";

        private static string currentSerial;
        
        private static void UpgradeMachineNameToSerialNumber(Transaction tran, string currentName, string newSerial) {
            if (newSerial.IsEmpty()) {
                throw new InvalidOperationException("Serial number cannot be empty");
            }

            string sql = "UPDATE ossys_parameter set host_serial = @currentSerial where upper(host) = @currentName and host_serial = host";
            using (var cmd = tran.CreateCommand(sql)) {
                cmd.CreateParameter("@currentSerial", DbType.String, newSerial);
                cmd.CreateParameter("@currentName", DbType.String, currentName.ToUpper());
                cmd.ExecuteNonQuery();
            }

            sql = "UPDATE ossys_server set host_serial = @currentSerial where upper(name) = @currentName and host_serial = name";
            using (var cmd = tran.CreateCommand(sql)) {
                cmd.CreateParameter("@currentSerial", DbType.String, newSerial);
                cmd.CreateParameter("@currentName", DbType.String, currentName.ToUpper());
                cmd.ExecuteNonQuery();
            }
        }

        private static void UpdateSerialNumber(Transaction tran, string previousSerial, string newSerial) {
            if (newSerial.IsEmpty()) {
                throw new InvalidOperationException("Serial number cannot be empty");
            }

            DBRuntimePlatform.Instance.UpdateSerialNumber(tran, previousSerial, newSerial);

            var sql = "UPDATE ossys_server set host_serial = @currentSerial where upper(host_serial) = @previousSerial";
            using (var cmd = tran.CreateCommand(sql)) {
                cmd.CreateParameter("@previousSerial", DbType.String, previousSerial.ToUpper());
                cmd.CreateParameter("@currentSerial", DbType.String, newSerial);
                cmd.ExecuteNonQuery();
            }
        }
        
        private static void UpdateMachineName(Transaction tran, string newSerial, string currentName) {
            if (newSerial.IsEmpty()) {
                throw new InvalidOperationException("Serial number cannot be empty");
            }

            string sql = "UPDATE ossys_server set name = @currentName where upper(host_serial) = @currentSerial";
            using (var cmd = tran.CreateCommand(sql)) {
                cmd.CreateParameter("@currentSerial", DbType.String, newSerial.ToUpper());
                cmd.CreateParameter("@currentName", DbType.String, currentName);
                cmd.ExecuteNonQuery();
            }

            sql = "UPDATE ossys_parameter set host = @currentName where upper(host_serial) = @currentSerial";
            using (var cmd = tran.CreateCommand(sql)) {
                cmd.CreateParameter("@currentSerial", DbType.String, newSerial.ToUpper());
                cmd.CreateParameter("@currentName", DbType.String, currentName);
                cmd.ExecuteNonQuery();
            }
        }
        
        private static string GetSerialFromOssysServer() {

            using (var tran = DatabaseAccess.ForSystemDatabase.GetCommitableTransaction()) {
                const string sql = "SELECT host_serial FROM ossys_Server where upper(name)=@hostname";
                using (var cmd = tran.CreateCommand(sql)) {
                    cmd.CreateParameter("@hostname", DbType.String, Settings.MachineName.ToUpper());
                    return cmd.ExecuteScalar().ToString();
                }
            }
        }
                
        private static RegistryKey SettingsRegistryKey {
            get { return Registry.LocalMachine.CreateSubKey(settingSubKey); }
        }

        [DoNotObfuscate]
        internal static int BestAlgorithmIndexForSettingsEncryption {
            [DoNotObfuscate] 
            get {
                return SecureConfidentialInformationEncryption.Algorithms.BestAlgorithmIndex;
            }
        }

	[DoNotObfuscate]
        public static int GetAlgorithmIndexForSettingsEncryption(string encryptedSettingValue) {
            return SecureConfidentialInformationEncryption.Algorithms.GetAlgorithmIndexForAlgorithmResult(encryptedSettingValue);
        }
        
        public static string MachineSerial {
            get {
                if (string.IsNullOrEmpty(currentSerial)) {

                    string exceptionMessage = string.Empty;

                    // get the serial number from the registry. Note that this is used only for
                    // accessing the ossys_parameter table, and not for license validation purposes,
                    // so there are no tampering concerns
                    try {
                        using (RegistryKey subKey = SettingsRegistryKey) {
                            object serialValue = subKey.GetValue(serialSetting);
                            currentSerial = serialValue == null ? null : serialValue.ToString();
                        }
                    } catch (Exception e) {
                        exceptionMessage = "Could not get serial from registry." + Environment.NewLine + e;
                    }

                    //  if could not get the serial from the ossys_server
                    if (string.IsNullOrEmpty(currentSerial)) {
                        try {
                            currentSerial = GetSerialFromOssysServer();
                        } catch (Exception e) {
                            if (!string.IsNullOrEmpty(exceptionMessage)) {
                                exceptionMessage += Environment.NewLine;
                            }
                            exceptionMessage += "Could not get serial from database." + Environment.NewLine + e;
                        }
                    }

                    if (string.IsNullOrEmpty(currentSerial)) {
                        throw new InvalidOperationException("Could not get host information. Please make sure the ConfigurationTool has already run." +
                            Environment.NewLine + exceptionMessage);
                    }
                }

                return currentSerial;
            }
        }
        
        public static void FixRegistrySettingsPermissions() {
            try {
                var rs = new RegistrySecurity();
                var rule = new RegistryAccessRule(new System.Security.Principal.SecurityIdentifier(System.Security.Principal.WellKnownSidType.WorldSid, null),
                                                                RegistryRights.FullControl, InheritanceFlags.ContainerInherit, PropagationFlags.InheritOnly, AccessControlType.Allow);
                rs.AddAccessRule(rule);

                using (RegistryKey subKey = Registry.LocalMachine.CreateSubKey(osRegistryKey)) {
                    if (subKey != null) {
                        subKey.SetAccessControl(rs);
                    }
                }
            } catch (Exception ex) {
                OSTrace.Error("FixRegistrySettingsPermissions: Failed to grant permissions to settings registry key.", ex);
            }
        }

        public static void UpdateSettingsMachineNameAndSerial(Func<string> serialNumberGetter) {
            UpdateSettingsMachineNameAndSerial(DatabaseAccess.ForCurrentDatabase, serialNumberGetter, /*skipConnectionStringCheck*/false);
        }

        public static void UpdateSettingsMachineNameAndSerial(DatabaseAccessProvider<IPlatformDatabaseServices> dbAccess, Func<string> serialNumberGetter, 
                bool skipConnectionStringCheck) {

            // This code is used to solve the dangling machine name problem in amazon.
            // We'll start using the serial number to identify a machine instead of its name
            // for the node-specific settings.

            if (skipConnectionStringCheck) {

                string currentName = Settings.MachineName;
                if (currentSerial == null) {
                    currentSerial = serialNumberGetter();
                }

                using (RegistryKey subKey = SettingsRegistryKey) {
                    object previousNameValue = subKey.GetValue(machineNameSetting);
                    string previousName = previousNameValue == null ? null : previousNameValue.ToString();
                    object previousSerialValue = subKey.GetValue(serialSetting);
                    string previousSerial = previousSerialValue == null ? null : previousSerialValue.ToString();

                    // the first time this code is run the ossys_parameter.host and ossys_server.name columns
                    // contain server names. Update them to the serial number.
                    // This is the 1st time if previousSerial is not set
                    if (previousSerial.IsEmpty()) {
                        FixRegistrySettingsPermissions();

                        currentSerial = serialNumberGetter();

                        using (var trans = dbAccess.GetCommitableTransaction()) {
                            UpgradeMachineNameToSerialNumber(trans, currentName, currentSerial);
                            trans.Commit();
			    			EventLogger.WriteInfo("Setting Machine Serial to '" + currentSerial + "'.");
                        }
                    }

                    // serial changed - this happens for new instances created from  a server image.
                    // Update the serial number to the new one
                    if (!previousSerial.IsEmpty() && previousSerial != currentSerial) {
                        using (var trans = dbAccess.GetCommitableTransaction()) {
                            
                            UpdateSerialNumber(trans, previousSerial, currentSerial);
                            trans.Commit();
                            EventLogger.WriteInfo("Machine Serial changed from '" + previousSerial + "' to '" + currentSerial + "'.");
                        }
                    }

                    // name changed - this happens with amazon instances whenever they're stopped/started.
                    // Update the machine name to the new one
                    if (!previousName.IsEmpty() && previousName != currentName) {
                        using (var trans = dbAccess.GetCommitableTransaction()) {
                            UpdateMachineName(trans, currentSerial, currentName);
                            trans.Commit();
                            EventLogger.WriteInfo("Machine Name changed from '" + previousName + "' to '" + currentName + "'.");
                        }
                    }

                    // update data in the registry
                    if (currentName == null) {
                        throw new InvalidOperationException("currentName or currentSerial is null");
                    }

                    subKey.SetValue(machineNameSetting, currentName);
                    
                    if (currentSerial == null) {
                        throw new InvalidOperationException("currentSerial is null");
                    }

                    subKey.SetValue(serialSetting, currentSerial);
                }
            }
        }

        public static bool SettingEncryptionNeedsUpgrade(string encryptedSettingValue) {            
            int algorithmIdx = GetAlgorithmIndexForSettingsEncryption(encryptedSettingValue);
            return algorithmIdx < BestAlgorithmIndexForSettingsEncryption;
        }

        public static void ClearSettingsEncryptionKeyCaches() {
            SecureConfidentialInformationEncryption.ClearEncryptionKeyCaches();
        }

        /// <summary>
        /// This method should be ONLY used for settings upgrade scenarios because it is able to decrypt settings encrypted with insecure algorithms.
        /// </summary>
        [Obsolete("This method should be ONLY used for settings upgrade scenarios.")]
        public static string DecryptStringForUpgrade(string text) {
            if (text != null) {
                try {
                    return SecureConfidentialInformationEncryption.DecryptForUpgrade(text);
                } catch (Exception e) {
                    //probably not encrypted
                    OSTrace.Error("Decrypting for upgrade", e);
                }
            }
            return text;
        }
        
        public static string EncryptMaintainingCompatibility(string text) {
            return SecureConfidentialInformationEncryption.EncryptMaintainingCompatibility(text);
        }
    }
}
