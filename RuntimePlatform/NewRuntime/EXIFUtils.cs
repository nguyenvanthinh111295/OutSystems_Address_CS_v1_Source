/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Goheer.EXIF;
using OutSystems.RuntimeCommon;

namespace OutSystems.HubEdition.RuntimePlatform.NewRuntime {
    public class EXIFUtils {

        public static byte[] ResizeImage(byte[] originalImage, int newWidth, int newHeight) {
            using (var image = Image.FromStream(new MemoryStream(originalImage))) {
                if (newHeight == 0 && newWidth != 0) {
                    newHeight = (int)(((double)newWidth / image.Width) * image.Height);
                } else if (newWidth == 0 && newHeight != 0) {
                    newWidth = (int)(((double)newHeight / image.Height) * image.Width);
                } else {
                    throw new Exception("image width or height must be set.");
                }
                using (MemoryStream ms = new MemoryStream()) {
                    var thumb = image.GetThumbnailImage(newWidth, newHeight, new Image.GetThumbnailImageAbort(() => false), IntPtr.Zero);
                    thumb.Save(ms, image.RawFormat);
                    return ms.ToArray();
                }
            }
            throw new Exception("Could not resize image");
        }

        public static byte[] FixEXIF(byte[] originalImage) {
            Bitmap bmp;
            using (var ms = new MemoryStream(originalImage)) {
                bmp = (Bitmap)Image.FromStream(ms, true, true);
                var exif = new EXIFextractor(ref bmp, "\n");
                byte[] orientedImage = originalImage;
                RotateFlipType flip = RotateFlipType.RotateNoneFlipNone;
                if (exif["Orientation"] != null) {
                    flip = OrientationToFlipType(exif["Orientation"].ToString());

                    // 0x112 is the id of the orientation
                    if (flip != RotateFlipType.RotateNoneFlipNone) {
                        bmp.RotateFlip(flip);

                        // reset EXIF orientation
                        int propertyId = 0x112;
                        int propertyLen = 2;
                        short propertyType = 3;
                        byte[] propertyValue = { 1, 0 };

                        exif.setTag(propertyId, propertyLen, propertyType, propertyValue);
                    }

                    using (MemoryStream saveMs = new MemoryStream()) {
                        bmp.Save(saveMs, System.Drawing.Imaging.ImageFormat.Jpeg);
                        orientedImage = saveMs.ToArray();
                    }                    
                }
                bmp.Dispose();
                return orientedImage;
            }
        }

        // Match the orientation code to the correct rotation:
        private static RotateFlipType OrientationToFlipType(string orientation) {
            switch (int.Parse(orientation)) {
                case 1:
                    return RotateFlipType.RotateNoneFlipNone;
                case 2:
                    return RotateFlipType.RotateNoneFlipX;
                case 3:
                    return RotateFlipType.Rotate180FlipNone;
                case 4:
                    return RotateFlipType.Rotate180FlipX;
                case 5:
                    return RotateFlipType.Rotate90FlipX;
                case 6:
                    return RotateFlipType.Rotate90FlipNone;
                case 7:
                    return RotateFlipType.Rotate270FlipX;
                case 8:
                    return RotateFlipType.Rotate270FlipNone;
                default:
                    return RotateFlipType.RotateNoneFlipNone;
            }
        }
    }
}
