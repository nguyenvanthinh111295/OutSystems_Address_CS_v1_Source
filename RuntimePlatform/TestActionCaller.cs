/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using OutSystems.RuntimeCommon;

namespace OutSystems.HubEdition.RuntimePlatform {

    public class TestActionCaller : MarshalByRefObject {

        public static string Invoke(string sharePath, string eSpaceName, string ptaName, string action, string[] parameters, out string result, out string exception) {

            AppDomain domain = null;
            try {

                string partialPath = sharePath + FileSystemUtils.PathSeparator + "partial" + FileSystemUtils.PathSeparator + ptaName;
                string partialBinPath = partialPath + FileSystemUtils.PathSeparator + "bin";
                string fullBinPath = sharePath + FileSystemUtils.PathSeparator + "full" + FileSystemUtils.PathSeparator + "bin";
                if (!Directory.Exists(partialBinPath)) { // no run has been done yet
                    Directory.CreateDirectory(partialBinPath);
                    var dllsToCopy = new string[] {
                        Path.GetFileName(Settings.Get(Settings.Configs.CompilerService_RuntimeCommon)),
                        Path.GetFileName(Settings.Get(Settings.Configs.CompilerService_RuntimePlatform)),
                        Path.GetFileName(Settings.Get(Settings.Configs.CompilerService_Auditing)),
                        Path.GetFileName(Settings.Get(Settings.Configs.CompilerService_DatabaseAbstractionLayer)),
                        Path.GetFileName(Settings.Get(Settings.Configs.DotNetCompilerService_SMS)),
                        Path.GetFileName(Settings.Get(Settings.Configs.CompilerService_WebWidgets)),
                        Path.GetFileName(Settings.Get(Settings.Configs.CompilerService_WidgetsRuntimeAPI)),
                        Path.GetFileName(Settings.Get(Settings.Configs.DotNetCompilerService_SharpZipLib)),
                        Path.GetFileName(Settings.Get(Settings.Configs.DotNetCompilerService_GemboxSpreadSheet)),
                        eSpaceName + ".dll",
                        eSpaceName + "CodeBehind.dll",
                    };
                    foreach (var dll in dllsToCopy) {
                        File.Copy(fullBinPath + FileSystemUtils.PathSeparator + dll,
                                  partialBinPath + FileSystemUtils.PathSeparator + dll);
                    }
                }

                string runtimePlatformFile = partialBinPath + FileSystemUtils.PathSeparator + Path.GetFileName(Settings.Get(Settings.Configs.CompilerService_RuntimePlatform));

                var info = new AppDomainSetup();
                info.ApplicationBase = partialPath;
                domain = AppDomain.CreateDomain("Test", null, info);

                var testActionCaller = (TestActionCaller)domain.CreateInstanceFromAndUnwrap(runtimePlatformFile, typeof(TestActionCaller).FullName);
                return testActionCaller.InnerInvoke(fullBinPath, eSpaceName, ptaName, action, parameters, out result, out exception);

            } catch (Exception e) {

                exception = e.Message;
                result = string.Empty;
                return "Internal Error";

            } finally {

                if (domain != null) {
                    try {
                        AppDomain.Unload(domain);
                    } catch (CannotUnloadAppDomainException ex) {
                        OSTrace.Error("Unloading Domain", ex);
                    }
                    ForceCleanup();
                }
            }
        }

        private string InnerInvoke(string fullBinPath, string eSpaceName, string ptaName, string action, string[] parameters, out string result, out string exception) {
            ResolveEventHandler handler = (sender, args) => {
                return Assembly.LoadFrom(Path.Combine(fullBinPath, args.Name.Split(',')[0] + ".dll"));
            };
            AppDomain.CurrentDomain.AssemblyResolve += handler;
            try {
                var assembly = Assembly.Load(eSpaceName);
                if (assembly == null) {
                    throw new Exception("Assembly '" + eSpaceName + "' not found");
                }
                var typeName = GetTypeName(eSpaceName, action);
                var type = assembly.GetType(typeName);
                if (type == null) {
                    throw new Exception("Type '" + typeName + "' not found");
                }
                var methodName = GetMethodName(eSpaceName, action);
                var method = type.GetMethod(methodName, new Type[] { typeof(string), typeof(string[]) });
                if (method == null || !method.ReturnParameter.ParameterType.Equals(typeof(string))) {
                    throw new Exception("Method '" + typeName + "." + methodName + "' not found");
                }
                try {
                    exception = string.Empty;
                    result = (string)method.Invoke(null, new object[] { ptaName, parameters });
                    return "OK";
                } catch (Exception ex) {
                    if (ex is TargetInvocationException) {
                        ex = ex.InnerException;
                    }
                    exception = ex.Message;
                    result = string.Empty;
                    return "Error";
                }
            } catch (Exception e) {
                exception = e.Message;
                result = string.Empty;
                return "Internal Error";
            }
        }

        private static string GetTypeName(string eSpaceName, string action) {
            if (action.StartsWith("Flows.UserAction.") || 
                action.StartsWith("Flows.UserActionInsideFolder.") ||
                action.StartsWith("ReferenceAction.") || 
                action.StartsWith("ReferenceActionInsideFolder.") ||
                action.StartsWith("TestFlows.TestStub.")) {
                return "ss" + eSpaceName + ".Actions";
            } 
            if (action.StartsWith("WebReferenceMethod.")) {                
                return "ss" + eSpaceName + ".ExtendedActions";
            }
            throw new InvalidOperationException("Invalid Action: " + action);
        }

        private static string GetMethodName(string eSpaceName, string action) {
            if (action.StartsWith("Flows.UserAction.")) {
                return "_Test_" + action.Substring("Flows.UserAction.".Length);
            }
            if (action.StartsWith("Flows.UserActionInsideFolder.")) {
                return "_Test_" + action.Substring("Flows.UserActionInsideFolder.".Length);
            }
            if (action.StartsWith("ReferenceAction.")) {
                return "_Test_" + action.Substring("ReferenceAction.".Length);
            }
            if (action.StartsWith("ReferenceActionInsideFolder.")) {
                return "_Test_" + action.Substring("ReferenceActionInsideFolder.".Length);
            }
            if (action.StartsWith("WebReferenceMethod.")) {
                return "_Test_" + action.Substring("WebReferenceMethod.".Length);
            } 
            if (action.StartsWith("TestFlows.TestStub.")) {
                return "_Test_TestStub_" + action.Substring("TestFlows.TestStub.".Length);
            } 
            throw new InvalidOperationException("Invalid Action: " + action);
        }

        [DllImport("kernel32.dll", EntryPoint = "SetProcessWorkingSetSize", ExactSpelling = true, CharSet = CharSet.Ansi, SetLastError = true)]
        private static extern int SetProcessWorkingSetSize(IntPtr process, int minimumWorkingSetSize, int maximumWorkingSetSize);

        private static void ForceCleanup() {
            GC.Collect();
            GC.WaitForPendingFinalizers();
            GC.Collect();
            GC.WaitForPendingFinalizers();
            GC.Collect();
            SetProcessWorkingSetSize(Process.GetCurrentProcess().Handle, -1, -1);
        }
    }
}
