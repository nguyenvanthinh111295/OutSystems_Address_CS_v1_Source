/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using OutSystems.RuntimeCommon;
using System.Web;
#if JAVA
using System.Text.RegularExpressions;
#endif

namespace OutSystems.HubEdition.RuntimePlatform {

    public class NetworkInterfaceUtils {

        public static IEnumerable<IPAddress> GetAllIpAddresses() {
            List<IPAddress> result = new List<IPAddress>();

            NetworkInterface[] nic = NetworkInterface.GetAllNetworkInterfaces();
            for (int i = 0; i < nic.Length; i++) {
                foreach (UnicastIPAddressInformation uni in nic[i].GetIPProperties().UnicastAddresses) {
                    if (!IsLoopbackAddress(uni.Address.ToString())) {
                        result.Add(uni.Address);
                    }
                }
            }

            return result;
        }

        public static string RemoveScopeIdFromIp(string ip) {
            int indexOfScopeId = ip.IndexOf('%');
            if (indexOfScopeId > 0) {
                ip = ip.Substring(0, indexOfScopeId);
            }
            return ip;
        }

        static volatile string cachedInternalAddress;
        public static bool IsLoopbackAddress(string hostnameOrIp) {
            hostnameOrIp = RemoveScopeIdFromIp(hostnameOrIp).Trim().ToLower();

            string internalAddress;
            if (HttpContext.Current == null) {
                // Can't cache this in services because settings change as diferent sandboxes are served
                internalAddress = Settings.Get(Settings.Configs.InternalAddress);
            } else {
                if (cachedInternalAddress == null) {
                    internalAddress = cachedInternalAddress = Settings.Get(Settings.Configs.InternalAddress);
                } else {
                    internalAddress = cachedInternalAddress;
                }
            }

            return hostnameOrIp.IsOneOf("127.0.0.1", "::1", "localhost", internalAddress);
        }

        public static bool IsLocalMachineAddress(string hostnameOrIP) {
            bool error;
            return IsLocalMachineAddress(hostnameOrIP, out error);
        }

        public static bool IsLocalMachineAddress(string hostnameOrIP, out bool error) {
            error = false;
            if (IsLoopbackAddress(hostnameOrIP)) {
                return true;
            }
            try {

                IPAddress[] hostnameIPs = Dns.GetHostAddresses(hostnameOrIP.Trim());
                IPAddress[] localhostIPs = Dns.GetHostAddresses(Dns.GetHostName());

                HashSet<IPAddress> localIPs = new HashSet<IPAddress>();
                localIPs.AddRange(localhostIPs);
                // #617204 ensure we also include the IP addresses configured for the interfaces, when detecting if an address is local or not
                localIPs.AddRange(GetAllIpAddresses());

                return localIPs.Any(ip => hostnameIPs.Contains(ip));
            } catch (Exception e) {
                OSTrace.Error("Checking if address is local address", e);
                error = true;
                return true;
            }
        }

        public static List<IPAddress> GetIps() {
            List<IPAddress> rtnIps = new List<IPAddress>();
            IPHostEntry host = Dns.GetHostEntry(Dns.GetHostName());
            string IPAddress = string.Empty;
            foreach (IPAddress ip in host.AddressList) {
                if (ip.AddressFamily == AddressFamily.InterNetwork) {
                    rtnIps.Add(ip);
                }
            }
            return rtnIps;
        }

        public class IPAddressRange {
            public string Name { get; set; }

            
            private readonly AddressFamily addressFamily;
            private readonly byte[] lowerBytes;
            private readonly byte[] upperBytes;

            public IPAddressRange(IPAddress lower, IPAddress upper) {
                
                this.addressFamily = lower.AddressFamily;
                this.lowerBytes = lower.GetAddressBytes();
                this.upperBytes = upper.GetAddressBytes();
            }

            public IPAddressRange(IPAddress ip, int netmask) {
                uint mask = ~(uint.MaxValue >> netmask);

                // Convert the IP address to bytes.
                byte[] ipBytes = ip.GetAddressBytes();

                // BitConverter gives bytes in opposite order to GetAddressBytes().
                byte[] maskBytes = BitConverter.GetBytes(mask).Reverse().ToArray();

                byte[] startIPBytes = new byte[ipBytes.Length];
                byte[] endIPBytes = new byte[ipBytes.Length];

                // Calculate the bytes of the start and end IP addresses.
                for (int i = 0; i < ipBytes.Length; i++) {
                    startIPBytes[i] = (byte)(ipBytes[i] & maskBytes[i]);
                    endIPBytes[i] = (byte)(ipBytes[i] | ~maskBytes[i]);
                }

                
                this.addressFamily = ip.AddressFamily;
                this.lowerBytes = startIPBytes;
                this.upperBytes = endIPBytes;
            }

            public bool IsInRange(IPAddress address) {
                
                if (address.AddressFamily != addressFamily) {
                    return false;
                }

                byte[] addressBytes = address.GetAddressBytes();

                bool lowerBoundary = true, upperBoundary = true;

                for (int i = 0; i < this.lowerBytes.Length &&
                    (lowerBoundary || upperBoundary); i++) {
                    if ((lowerBoundary && addressBytes[i] < lowerBytes[i]) ||
                        (upperBoundary && addressBytes[i] > upperBytes[i])) {
                        return false;
                    }

                    lowerBoundary &= (addressBytes[i] == lowerBytes[i]);
                    upperBoundary &= (addressBytes[i] == upperBytes[i]);
                }

                return true;
            }
        }

#if JAVA
        // Note: The ipv6 regex part is letting pass more ips than allowed
        private static Regex IPRegEx = new Regex(@"(^((25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]?[0-9])$)|(^([0-9A-F]{0,4}:{1,2}){1,7}[0-9A-F]{0,4}([0-9]{1,3}(\.[0-9]{1,3}){3})?$)", RegexOptions.Compiled | RegexOptions.CultureInvariant | RegexOptions.IgnoreCase | RegexOptions.Singleline);

        public static bool IsStringAnIP(string IP) {
            return IPRegEx.Match(IP).Success;
        }
#else
        public static bool IsStringAnIP(string ip) {
            IPAddress ipAddress;
            return IPAddress.TryParse(ip, out ipAddress);
        }
#endif

        public static List<IPAddress> DnsLookup(string address) {

            IPAddress[] ip_list = null;

            try {
                ip_list = Dns.GetHostEntry(address).AddressList;
            } catch (Exception e) {
                OSTrace.Error("Dns Lookup", e);
            }

            if (ip_list != null && ip_list.Length > 0) {
                return ip_list.ToList();
            }

            // Dns.GetHostEntry performs a more thorough lookup (reverse dns lookup in addition to the forward dns lookup)
            // which will fail to retrieve the ip address in some scenarios where the GetHostAddresses will succeed.

            try {
                ip_list = Dns.GetHostAddresses(address);
            } catch (Exception e) {
                OSTrace.Error("Dns Lookup Extended", e);
            }

            if (ip_list != null && ip_list.Length > 0) {
                return ip_list.ToList();
            }

            throw new Exception("Unable to resolve address:" + address);
        }
    }
}
