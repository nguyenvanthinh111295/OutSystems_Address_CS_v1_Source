/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Web;
using OutSystems.HubEdition.RuntimePlatform.Cache;
using OutSystems.HubEdition.RuntimePlatform.Internal;
using OutSystems.HubEdition.RuntimePlatform.IPAddressRangeLib;
using OutSystems.HubEdition.RuntimePlatform.Log;
using OutSystems.HubEdition.RuntimePlatform.SessionState;
using OutSystems.Internal.Db;
using OutSystems.ObjectKeys;
using OutSystems.RuntimeCommon;
using OutSystems.HubEdition.RuntimePlatform.WebReference;

namespace OutSystems.HubEdition.RuntimePlatform {

    public partial class RuntimePlatformUtils {

        [Obsolete("This is deprecated, use Constants.DefaultEncoding instead")]
        public static Encoding DefaultEncoding { get { return Constants.DefaultEncoding; } }

        public static bool FromBrowserRequest() {
            return !HttpContext.Current.Request.UserAgent.IsEmpty();
        }

        public static bool ShouldCreateCookieForRequest() {
            return !HttpContext.Current.Request.UserAgent.IsEmpty() &&
                !HttpContext.Current.Request.UserAgent.Contains("RichMail") &&
                !HttpContext.Current.Request.UserAgent.Contains("Apache-HttpClient") &&
                !Settings.GetBool(Settings.Configs.DisableMetricsCollect);
        }

        public static bool IsValidRequestForVisit() {
            return ShouldCreateCookieForRequest() && !NetworkInterfaceUtils.IsLoopbackAddress(HttpContext.Current.Request.UserHostAddress);
        }

        public static string GetClientIpForLogging() {
            var context = HttpContext.Current;
            if (context != null) {
                try {
                    string address = context.Request.UserHostAddress;
                    string xForwardedFor = context.Request.ServerVariables["HTTP_X_FORWARDED_FOR"];
                    if (!xForwardedFor.IsEmpty()) {
                        xForwardedFor = xForwardedFor.SafeSplit(',').FirstOrDefault();
                        if (!xForwardedFor.IsEmpty() && xForwardedFor.ToLowerInvariant() != "unknown") {
                            return address + " X-Forwarded-For: " + xForwardedFor;
                        }
                    }
                    return address;
                } catch {
                    return null;
                }
            }
            return null;
        }

        /// <summary>
        /// This is the extension for the eSpace cache files... used by the compiler and the compiler service...
        /// </summary>
        public const string CacheFileExtension = ".cache";

        /// <summary>
        /// This is the extesion for the cache control files... those used by the tenant invalidate cache, etc...
        /// </summary>
        public const string CACHE_CONTROL_FILE_EXT = ".osc";

        private static string RetrievedSessionSize = "RetrievedSessionSize";
        public static int GetRetrievedSessionSize() {
            if (HttpContext.Current.Items[RetrievedSessionSize] == null) {
                return 0;
            } else {
                return (int)HttpContext.Current.Items[RetrievedSessionSize];
            }
        }

        public static void SetRetrievedSessionSize(HttpContext context, int val) {
            context.Items[RetrievedSessionSize] = val;
        }

        public static void IncrementRetrievedSessionSize(int val) {
            HttpContext.Current.Items[RetrievedSessionSize] = GetRetrievedSessionSize() + val;
        }

        private static string RetrievedSessionRequests = "RetrievedSessionRequests";

        public static int GetRetrievedSessionRequests() {
            if (HttpContext.Current.Items[RetrievedSessionRequests] == null) {
                return 1;
            } else {
                return (int)HttpContext.Current.Items[RetrievedSessionRequests];
            }
        }

        public static void IncrementRetrievedSessionRequests() {
            HttpContext.Current.Items[RetrievedSessionRequests] = GetRetrievedSessionRequests() + 1;
        }

        private static string ViewstateSize = "ViewstateSize";
        public static int GetViewstateSize() {
            if (HttpContext.Current.Items[ViewstateSize] == null) {
                return 0;
            } else {
                return (int)HttpContext.Current.Items[ViewstateSize];
            }
        }
        public static void SetViewstateSize(int val) {
            HttpContext.Current.Items[ViewstateSize] = val;
        }

        public static string ExecuteDataBind(EventHandler databind, object sender) {
            return ExecuteDataBind(databind, sender, null);
        }

        public static string ExecuteDataBind(EventHandler databind, object sender, EventArgs args) {
            databind(sender, args);
            return string.Empty;
        }

        private static long TicksFrom1900_3_1 = new DateTime(1900, 3, 1).Ticks;

        public static object ExcelFixWrongDateTimeVals(object val) {
            if (val is DateTime && ((DateTime)val).Ticks < TicksFrom1900_3_1) {
                val = ((DateTime)val).AddDays(-1);
            }
            return val;
        }

        public static bool AppendStaticSuffixForLevel(CacheInvalidationMangleDepth level) {
            string userlevel = Settings.Get(Settings.Configs.Compiler_UseCacheInvalidationSuffix);
            switch (userlevel.ToLowerInvariant()) {
                case "all":
                    return true;
                case "css":
                    return true;
                case "pagecontents":
                    return (level == CacheInvalidationMangleDepth.PlatformInserted || level == CacheInvalidationMangleDepth.None);
                case "none":
                    return (level == CacheInvalidationMangleDepth.None);
                default:
                    return false;
            }
        }

        public static string EncodeFilenameForDownload(string filename) {
            return HttpUtility.UrlEncode(filename).Replace("+", " ");
        }

        // #155815 Removed the regex aplied to the filename to alow more characters.
        // According to this (http://tools.ietf.org/html/rfc822#section-3.1) we can use double quotes to do that in the header.
        // Now it apply this regex [\*\|\\:\<">?/] to the original filename, writing the result of the regex.replace between double quotes.
        public static string EscapeFilenameForDownload(string filename) {
            return Regex.Replace(filename.Trim(), "[\\*\\|:<>\\\"\\\\?/\\r\\n]", "", RegexOptions.Singleline);
        }


        public static string GetHostNameForJava() {
            return null;
        }

        public static void ChangeDefaultEncoding(bool isJava) {
            // The .NET encoding must use BOM, while the Java encoding can't use BOM
            // This is here to ensure the correct encoding is used for each stack
            Constants.DefaultEncoding = new UTF8Encoding(!isJava);
        }

        public static readonly string LateLoadBinariesDirectory = "bin2";

        public static readonly string ExtensionBinariesDirectory = "bin2";

        public static bool IsDefaultEncodingString(byte[] data) {
            if (data.Length > 2) {
                // The UTF-8 identifier is the Unicode byte order mark (0xFEFF) written in UTF-8 (0xEF 0xBB 0xBF).
                return (0xff & data[0]) == 0xEF && (0xff & data[1]) == 0xBB && (0xff & data[2]) == 0xBF;
            }
            return false;
        }


        public static List<IPAddress> GetMachineOwnAddresses() {
            var ranges = new List<IPAddress>();

            string hostname = Dns.GetHostName();
            var machineAddresses = Dns.GetHostEntry(hostname);

            foreach (var ipaddr in machineAddresses.AddressList) {
                ranges.Add(ipaddr);
            }
            ranges.Add(IPAddress.Parse("127.0.0.1"));
            ranges.Add(IPAddress.Parse("::1"));
            return ranges;
        }

        private static List<IPAddressRange> InitIPAddressRanges(string settingName) {
            var result = new List<IPAddressRange>();
            string ipList = Settings.Get(settingName, true);
            if (ipList != null) {
                IPAddressRange parsedIPRange = null;
                foreach (string ip in ipList.Split(';')) {
                    if (IPAddressRange.TryParse(ip.Trim(), out parsedIPRange)) {
                        result.Add(parsedIPRange);
                    }
                }
            }
            if (!result.IsEmpty()) {
                foreach (IPAddress addr in GetMachineOwnAddresses()) {
                    result.Add(new IPAddressRange(addr));
                }
            }
            return result;
        }


        private static CacheWithClear<List<IPAddressRange>> InternalIPAddressRanges = new CacheWithClear<List<IPAddressRange>>(InitInternalIPAddressRanges);
        private static List<IPAddressRange> InitInternalIPAddressRanges() {
            return InitIPAddressRanges(Settings.Configs.InternalNetwork_IPAdressList);
        }


        private static CacheWithClear<List<IPAddressRange>> TrustedProxyAddressRanges = new CacheWithClear<List<IPAddressRange>>(InitTrustedProxyAddressRanges);
        private static List<IPAddressRange> InitTrustedProxyAddressRanges() {
            return InitIPAddressRanges(Settings.Configs.TrustedProxyAddresses);
        }


        private static CacheWithClear<List<string>> InternalIPAddresses = new CacheWithClear<List<string>>(InitInternalIPAddresses);
        private static List<string> InitInternalIPAddresses() {
            var tmp = new List<string>();
            string ipList = Settings.Get(Settings.Configs.InternalNetwork_IPAdresses, true);
            if (ipList != null) {
                foreach (string ip in ipList.Split(';')) {
                    if (ip != string.Empty) {
                        if (IPAddressValidationLegacy(ip.Trim())) {
                            tmp.Add(ip.Trim());
                        }
                    }
                }
            }
            return tmp;
        }


        public static ApplicationServerStack getServerStack() {
#if JAVA
            return ApplicationServerStack.Java;
#else
            return ApplicationServerStack.Net;
#endif
        }

        public static bool IsJava() {
            return getServerStack() == ApplicationServerStack.Java;
        }

        //#49674
        public static readonly string SessionPrefixJava = "(";
        public static readonly string SessionPrefixDotNET = "(S(";
        public static readonly string SessionSuffixJava = ")";
        public static readonly string SessionSuffixDotNET = "))";

        public static string SessionPrefix {
            get {
                if (IsJava()) {
                    return SessionPrefixJava;
                } else {
                    return SessionPrefixDotNET;
                }
            }
        }

        public static string SessionSuffix {
            get {
                if (IsJava()) {
                    return SessionSuffixJava;
                } else {
                    return SessionSuffixDotNET;
                }
            }
        }

        [Obsolete("Please use GetLibFileExtension()")]
        public static string GetLibFileExtension(ApplicationServerKind serverKind) {
            return GetLibFileExtension();
        }

        public static string GetLibFileExtension() {
            if (!IsJava()) {
                return ".dll";
            } else {
                return ".jar";
            }
        }

        [Obsolete("Please use GetUIFileExtension()")]
        public static string GetUIFileExtension(ApplicationServerKind serverKind) {
            return GetUIFileExtension();
        }

        public static string GetUIFileExtension() {
            if (!IsJava()) {
                return ".ascx";
            } else {
                return ".jsp";
            }
        }

        [Obsolete("Please use GetLibDirectoryName()")]
        public static string GetLibDirectoryName(ApplicationServerKind serverKind) {
            return GetLibDirectoryName();
        }

        public static string GetLibDirectoryName() {
            if (!IsJava()) {
                return "bin";
            } else {
                return "lib";
            }
        }

        [Obsolete("Please use GetUIDirectoryName()")]
        public static string GetUIDirectoryName(ApplicationServerKind serverKind) {
            return GetUIDirectoryName();
        }

        public static string GetUIDirectoryName() {
            if (!IsJava()) {
                return "";
            } else {
                return "jsp";
            }
        }

        [Obsolete("Please use GetWidgetsDirectoryName()")]
        public static string GetWidgetsDirectoryName(ApplicationServerKind serverKind) {
            return GetWidgetsDirectoryName();
        }

        public static string GetWidgetsDirectoryName() {
            if (!IsJava()) {
                return "Blocks";
            } else {
                return "jsp" + FileSystemUtils.PathSeparator + "Blocks";
            }
        }

        public static string GetCodeBehindLibSuffix() {
            return "CodeBehind";
        }

        [Obsolete("Please use GetImagesDirectoryName()")]
        public static string GetImagesDirectoryName(ApplicationServerKind serverKind) {
            return GetImagesDirectoryName();
        }

        public static string GetImagesDirectoryName() {
            if (!IsJava()) {
                return "img";
            } else {
                return "jsp" + FileSystemUtils.PathSeparator + "img";
            }
        }

        public static string RemoveTrailingZeros(string str, NumberFormatInfo formatInfo) {
            int pos;
            if (str == null) {
                return str;
            }
            if (str.IndexOf(formatInfo.NumberDecimalSeparator) == -1) {
                return str;
            }
            pos = str.Length - 1;
            while (str[pos] == '0') {
                pos--;
            }
            // Remove the last .
            if (formatInfo.NumberDecimalSeparator.IndexOf(str[pos]) != -1) {
                pos--;
            }
            str = str.Substring(0, pos + 1);
            return str;
        }

        /// <summary>
        /// Stops execution until VS Debugger is attached
        /// </summary>
        public static void CheckAndWaitForDebugger() {
            bool waitForDebugger;
            if (DatabaseAccess.BlockAccess || !bool.TryParse(Settings.Get(Settings.Configs.Service_WaitForDebugger), out waitForDebugger)) {
                waitForDebugger = false;
            }
            if (waitForDebugger) {
                OSTrace.TimerStart("Waiting for Debugger");
                while (true) {
                    if (System.Diagnostics.Debugger.IsAttached) {
                        break;
                    }
                    Thread.Sleep(1000);
                }
                OSTrace.TimerEnd("Waiting for Debugger");
            }
        }

        public static string JavaScriptEscString(string s) {
            return BuiltInFunction.EncodeJavascript(s);
        }

        public static string ConvertCRLFToWhitespace(string text) {
            text = text.Replace("\r\n", " ");
            text = text.Replace("\n", " ");
            text = text.Replace("\r", " ");
            return text;
        }

        public static string ExtendedHtmlEncode(string s) {
            return BuiltInFunction.EncodeHtml(s);
        }

        public static string GetSession(string eSpaceName, string tenantName, bool isMultitenant) {
            string url = "http://localhost/" + eSpaceName + "/_ping.aspx";
            var request = (HttpWebRequest)WebRequest.Create(url);
            request.Method = "HEAD";
            request.AllowAutoRedirect = false;
            HttpWebResponse response = null;
            string session = "";
            try {
                response = (HttpWebResponse)request.GetResponse();
                if (response.StatusCode == HttpStatusCode.Found) {
                    string[] splitRes = response.Headers["Location"].Split(new string[] { RuntimePlatformUtils.SessionPrefix, RuntimePlatformUtils.SessionSuffix }, StringSplitOptions.None); // #49674
                    if (splitRes.Length > 3) {
                        throw (new InvalidOperationException("Result contains parenthesis... " + response.Headers["Location"]));
                    }
                    session = splitRes[1];
                }
            } finally {
                try {
                    if (response != null) {
                        response.Close();
                    }
                } catch {
                }
            }
            return session;
        }

        public static bool TestAndSetTimerNextRun(HeContext heContext, ObjectKey timerKey, int producerEspaceId) {
            return TestAndSetTimerNextRun(heContext, timerKey, producerEspaceId, AppInfo.GetAppInfo().Tenant.Id);
        }

        public static bool TestAndSetTimerNextRun(HeContext heContext, ObjectKey timerKey, int producerEspaceId, int tenantId) {
            using (Transaction privTran = DatabaseAccess.ForSystemDatabase.GetCommitableTransaction()) {
                // Check if the timer is running. If so, do nothing and return false
                bool isShared;
                int cyclicJobId = DBRuntimePlatform.Instance.GetCyclicJobId(privTran, producerEspaceId, tenantId, timerKey, out isShared);
                DateTime isRunningSince, lastRun, nextRun;
                string schedule, isRunBy;
                bool result = false;
                if (DBRuntimePlatform.Instance.GetCyclicJobForUpdate(privTran, cyclicJobId, isShared, out isRunningSince, out schedule,
                    out lastRun, out nextRun, out isRunBy)) {

                    result = isRunningSince == BuiltInFunction.NullDate();
                    DBRuntimePlatform.Instance.UpdateCyclicJob(privTran, cyclicJobId, isShared);
                    privTran.Commit();
                }
                return result;
            }
        }

        [Obsolete("Deprecated. Please get tenantId and eSpaceId from session.")]
        public static void GetRunningIDs(int producerEspaceId, out int tenantId, out int eSpaceId) {
            var app = AppInfo.GetAppInfo();
            tenantId = app.Tenant.Id;
            eSpaceId = producerEspaceId;
        }

        public static bool CompareByteArrays(byte[] arr1, byte[] arr2) {
            if (arr1.Length != arr2.Length) {
                return false;
            }
            for (int i = 0; i < arr1.Length; i++) {
                if (arr1[i] != arr2[i]) {
                    return false;
                }
            }
            return true;
        }

        private static bool IPAddressValidation(string ipAddress, out IPAddress address) {
            return IPAddress.TryParse(ipAddress, out address);
        }

        public static bool IPAddressIsValidIPv4(string ipAddress) {
            var m = Regex.Match(
                ipAddress,
                "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$",
                RegexOptions.IgnoreCase | RegexOptions.Singleline);
            return m.Success;
        }

        public static bool IPAddressIsValidIPv6(string ipAddress) {
            var m1 = Regex.Match(
                ipAddress,
                "\\A((?:[0-9A-Fa-f]{1,4}(?::[0-9A-Fa-f]{1,4})*)?) ::((?:[0-9A-Fa-f]{1,4}:)*)(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}(?:%[0-9A-Za-z]*)?\\z",
                RegexOptions.IgnoreCase | RegexOptions.Singleline);

            var m2 = Regex.Match(
                ipAddress,
                "\\A((?:[0-9A-Fa-f]{1,4}(?::[0-9A-Fa-f]{1,4})*)?) ::((?:[0-9A-Fa-f]{1,4}:)*)(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}(?:%[0-9A-Za-z]*)?\\z",
                RegexOptions.IgnoreCase | RegexOptions.Singleline);

            var m3 = Regex.Match(
                ipAddress,
                "\\A((?:[0-9A-Fa-f]{1,4}(?::[0-9A-Fa-f]{1,4})*)?)::((?:[0-9A-Fa-f]{1,4}(?::[0-9A-Fa-f]{1,4})*)?)(?:%[0-9A-Za-z]*)?\\z",
                RegexOptions.IgnoreCase | RegexOptions.Singleline);

            var m4 = Regex.Match(
                ipAddress,
                "\\A(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}(?:%[0-9A-Za-z]*)?\\z",
                RegexOptions.IgnoreCase | RegexOptions.Singleline);

            return m1.Success || m2.Success || m3.Success || m4.Success;
        }

        private static bool IPAddressValidationLegacy(string ipAddress) {
            var m = Regex.Match(
                ipAddress,
                @"(^(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])$)|" +
                    @"(^(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.{0,1}$)|" +
                    @"(^(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.{0,1}$)|" +
                    @"(^(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.{0,1}$)",
                RegexOptions.IgnoreCase | RegexOptions.Singleline);
            return m.Success;
        }

        private static bool IPAddressValidation(string ipAddress) {
            IPAddress dummy;
            return IPAddressValidation(ipAddress, out dummy);
        }

        public static bool InternalAddressIdentification(HttpRequest request) {
            // If both features are disabled, we just use UserHostAddress which was the old behavior (dumped by the compiler).
            var requestAddress = request.UserHostAddress;

            if (Settings.GetBool(Settings.Configs.EnableTrustedProxies) ||
                Settings.GetBool(Settings.Configs.EnableInternalNetworkNewBehaviour)) {
                requestAddress = GetRequestRealIP(request);
            }

            return InternalAddressIdentification(requestAddress);
        }

        public static void ClearInternalNetworkSettings() {
            InternalIPAddresses.Clear();
            InternalIPAddressRanges.Clear();
            TrustedProxyAddressRanges.Clear();
        }

        // Avoid using this method directly. Use the one that receives HttpRequest instead.
        public static bool InternalAddressIdentification(string ipAddress) {

            if (Settings.GetBool(Settings.Configs.EnableInternalNetworkNewBehaviour)) {
                IPAddress ip = null;

                var internalIpAddressRanges = InternalIPAddressRanges.GetValue();

                if (IPAddressValidation(ipAddress, out ip)) {
                    foreach (var iprange in internalIpAddressRanges) {
                        if (iprange.Contains(ip)) {
                            return true;
                        }
                    }
                }

                return internalIpAddressRanges.Count == 0;

            } else {

                var addresses = InternalIPAddresses.GetValue();
                foreach (string ip in addresses) {
                    if (ipAddress.StartsWith(ip)) {
                        return true;
                    }
                }
                return (addresses.Count == 0);
            }
        }

        public static string BitToSSBoolean(object field) {
            return (Convert.ToBoolean(field)) ? "Yes" : "No";
        }

        /// <summary>
        /// Convert an object to string
        /// To be used for saving values in a database string field
        /// </summary>
        /// <param name="val">Object to be converted into a String.</param>
        /// <returns>A String representing the given object</returns>
        public static string ConvertToString(object val) {
            if (val is DateTime) {
                return ((DateTime)val).ToString(Constants.DateTimeFormat, Constants.DateTimeFormatProvider);
            } else if (val is decimal) {
                return BuiltInFunction.DecimalToText((decimal)val);
            } else if (val is bool) {
                return ((bool)val) ? "True" : "False";
            } else {
                return val.ToString();
            }
        }

        /// <summary>
        /// Convert an string to object.
        /// To be used for retrieve values from a database string field
        /// </summary>
        /// <param name="val">String to be converted</param>
        /// <param name="datatype">The runtime string representation of the desired datatype.</param>
        /// <returns>An object created from the given String based on the data type.</returns>
        public static object ConvertFromString(string val, string datatype) {
            switch (datatype) {
                case "rtText":
                case "rtPhoneNumber":
                case "rtEmail":
                    return val;
                case "rtInteger":
                    if (val == string.Empty) {
                        val = "0";
                    }
                    return Convert.ToInt32(val);
                case "rtLongInteger":
                    if (val == string.Empty) {
                        val = "0";
                    }
                    return Convert.ToInt64(val);
                case "rtDecimal":
                case "rtCurrency":
                    if (val == string.Empty) {
                        val = "0.0";
                    }
                    return ScriptableBuiltInFunction.TextToDecimal(val);
                case "rtBoolean":
                    if (val == string.Empty) {
                        val = "true";
                    }
                    return val.ToLower() == "true";
                case "rtDateTime":
                    if (val == "") {
                        val = "1900-01-01 00:00:00";
                    }
                    return ScriptableBuiltInFunction.TextToDateTime(val);
                case "rtDate":
                    if (val == "") {
                        val = "1900-01-01";
                    }
                    return ScriptableBuiltInFunction.TextToDate(val);
                case "rtTime":
                    if (val == "") {
                        val = "00:00:00";
                    }
                    return ScriptableBuiltInFunction.TextToTime(val);
                default:
                    throw (new ArgumentException("Don't know how to convert " + datatype));
            }
        }

        // If input string is null, returns "" instead
        public static string NoNull(string inStr) {
            return inStr ?? string.Empty;
        }

        public static string Trunc(string s, int len) {
            if (s.Length > len) {
                return s.Substring(0, len);
            } else {
                return s;
            }
        }

        public static string TruncNoNull(string str, int maxSize) {
            return Trunc(NoNull(str), maxSize);
        }

        public static void RedirectAndroidDownloadToExternalPage(string url) {
            var context = HttpContext.Current;
            var response = context.Response;
            response.Clear();
            response.StatusCode = 302;
            
            {
                url = response.ApplyAppPathModifier(url);
                response.StatusDescription = "Found";
            }
            response.AddHeader("Location", url);
            response.CacheControl = "private";
            
            response.Write("<html><head><title>No title</title></head><body><h2>Object moved to <a href='" + HttpUtility.HtmlEncode(url) + "'>here</a>.</h2></body></html>\r\n");
            response.Flush();
        }

        private static HEMessageException HandleReadPersistentDataException(string fullPath, Exception ex) {
            var he = new HEMessage("PersistenceCacheReadError",
                                   "Internal Error",
                                   "Could not load persistence information file '" + fullPath + "'" + (ex != null ? (": " + ex.Message) : ""),
                                   2063,
                                   ex != null ? ex.StackTrace : "",
                                   HEMessageType.Error,
                                   true);
            return new HEMessageException(he);
        }

        private static HEMessageException HandleWritePersistentDataException(string fullPath, Exception ex) {
            var he = new HEMessage("PersistenceCacheCreateError",
                                   "Internal Error",
                                   "Could not create persistence information file '" + fullPath + "'" + (ex != null ? (": " + ex.Message) : ""),
                                   2063,
                                   ex != null ? ex.StackTrace : "",
                                   HEMessageType.Error,
                                   true);
            return new HEMessageException(he);
        }

        public static object TryReadPersistentData(string path, string filename) {
            string fullPath = GetCacheFileName(path, filename);
            if (!File.Exists(fullPath)) {
                return null;
            }
            FileStream fs = null;
            try {
                fs = File.OpenRead(fullPath);
                var bf = new BinaryFormatter();
                return bf.Deserialize(fs);
            } catch (Exception) {
                return null;
            } finally {
                if (fs != null) {
                    fs.Close();
                }
            }
        }

        public static object ReadPersistentData(string filename) {
            return ReadPersistentData(string.Empty, filename);
        }

        public static object ReadPersistentData(string path, string filename) {
            string fullPath = GetCacheFileName(path, filename);
            if (!File.Exists(fullPath)) {
                throw HandleReadPersistentDataException(fullPath, /*Exception*/null);
            }
            FileStream fs = null;
            try {
                fs = File.OpenRead(fullPath);
                var bf = new BinaryFormatter();
                return bf.Deserialize(fs);
            } catch (Exception e) {
                throw HandleReadPersistentDataException(fullPath, e);
            } finally {
                if (fs != null) {
                    try {
                        fs.Close();
                    } catch (Exception e) {
                        throw HandleReadPersistentDataException(fullPath, e);
                    }
                }
            }
        }


        public static void WritePersistentData(string path, string filename, object data) {
            Stream fs = null;
            try {
                fs = CreateCacheFile(path, filename);
                BinaryFormatter bf = new BinaryFormatter();
                bf.Serialize(fs, data);
            } finally {
                if (fs != null) {
                    fs.Close();
                }
            }
        }

        public static Stream CreateCacheFile(string path, string filename) {
            string fullPath = GetCacheFileName(path, filename);
            try {
                return File.Create(fullPath);
            } catch (Exception e) {
                throw HandleWritePersistentDataException(fullPath, e);
            }
        }

        public static bool CacheFileExists(string path, string filename) {
            string fullPath = GetCacheFileName(path, filename);
            return File.Exists(fullPath);
        }

        public static Stream OpenCacheFile(string path, string filename) {
            string fullPath = GetCacheFileName(path, filename);
            if (!File.Exists(fullPath)) {
                throw HandleReadPersistentDataException(fullPath, /*Exception*/null);
            }
            try {
                return File.OpenRead(fullPath);
            } catch (Exception e) {
                throw HandleReadPersistentDataException(fullPath, e);
            }
        }

        public static void DeleteCacheFile(string path, string filename) {
            string fullPath = GetCacheFileName(path, filename);
            try {
                if (File.Exists(fullPath)) {
                    File.Delete(fullPath);
                }
            } catch (Exception e) {
                HEMessage he = new HEMessage("PersistenceCacheDeleteError",
                                             "Internal Error",
                                             "Could not delete persistence information file '" + fullPath + "' " + e.Message,
                                             0,
                                             e.StackTrace,
                                             HEMessageType.Error,
                                             true);
                throw new HEMessageException(he);
            }
        }

        public static string GetCacheFileName(string path, string filename) {
            string fullPath = string.IsNullOrEmpty(path) ? string.Empty : Path.GetFullPath(path);
            string fullPathFilename = string.IsNullOrEmpty(filename) ? string.Empty : Path.GetFullPath(filename);
            string filepath;
            if (fullPath.IsEmpty() || fullPathFilename.StartsWith(fullPath)) {
                filepath = filename + CacheFileExtension;
            } else {
                filepath = Path.Combine(path, filename + CacheFileExtension);
            }
            return Path.GetFullPath(filepath);
        }

        private struct ActionAndBlockReferencesIds {
            public readonly int id, versionId;
            public ActionAndBlockReferencesIds(int id, int versionId) {
                this.id = id;
                this.versionId = versionId;
            }
        }

        private static void AddActionAndBlockReferencesEspaceIdsRecurse(int versionId, int eSpaceId, ArrayList visited, Transaction tran) {
            visited.Add(eSpaceId);

            LinkedList<ActionAndBlockReferencesIds> ids = new LinkedList<ActionAndBlockReferencesIds>();
            using (IDataReader reader = DBRuntimePlatform.Instance.GetActionAndBlockReferencesInfo(tran, versionId)) {
                ids.AddLast(new ActionAndBlockReferencesIds(Convert.ToInt32(reader["ID"]), Convert.ToInt32(reader["VERSION_ID"])));
            }

            foreach (ActionAndBlockReferencesIds id in ids) {
                int refEspaceId = id.id;
                int refVersionId = id.versionId;
                if (!visited.Contains(refEspaceId)) {
                    AddActionAndBlockReferencesEspaceIdsRecurse(refVersionId, refEspaceId, visited, tran);
                }
            }
        }

        public static ArrayList GetActionAndBlockReferencesEspaceIds(int eSpaceId) {
            var eSpaceIds = new ArrayList();
            int thisVersionId;

            using (var tran = DatabaseAccess.ForSystemDatabase.GetReadOnlyTransaction()) {
                //get producer tenant id
                object Id = DBRuntimePlatform.Instance.GetVersionIdFromEspaceId(tran, eSpaceId);
                if (!(Id is DBNull)) {
                    thisVersionId = Convert.ToInt32(Id);
                    AddActionAndBlockReferencesEspaceIdsRecurse(thisVersionId, eSpaceId, eSpaceIds, tran);
                    eSpaceIds.Remove(eSpaceId);
                }
            }
            return eSpaceIds;
        }

        public static void SetScriptTimeout(int timeoutInSecs) {
            if (timeoutInSecs == 0) {
                throw new ArgumentOutOfRangeException("timeoutInSecs", "The timeout for HTTP requests should be different from 0 (zero).");
            }
            
            HttpContext.Current.Server.ScriptTimeout = timeoutInSecs;
        }

        public static void SetSessionItemTimeout(int timeoutInMins) {
            // obtain current session
            System.Web.SessionState.HttpSessionState session = HttpContext.Current.Session;
            // check if it is necessary to set the new timeout
            if (session != null && session.Timeout != timeoutInMins) {
                session.Timeout = timeoutInMins;
                SqlSessionStateStore.SetItemTimeout(session.SessionID, timeoutInMins);
            }
        }

        public static bool IsSocketException(Exception ex) {
            
            return ex is System.Net.Sockets.SocketException;
        }

        public static bool isWindows() {
            
            return true;
        }

        public static bool TestAndSetProducerSession(string eSpaceName) {
            if (HttpContext.Current.Session != null) {
                HeContext heContext = AppInfo.GetAppInfo().OsContext;
                return heContext.Session.TestAndSetNeedsSessionStart(eSpaceName);
            }
            return false;
        }

        public static bool PersistentDataExists(string path, string filename) {
            return File.Exists(GetCacheFileName(path, filename));
        }

        public static string connectionStringJoin(string conStr, string parameters) {
            if (!conStr.TrimEnd().EndsWith(";")) {
                conStr += ";";
            }

            return conStr + (parameters ?? "");
        }

        public static bool RequestIsSecure(HttpRequest request) {
            return RequestIsSecure(request, true);
        }

        public static bool RequestIsSecure(HttpRequest request, bool allowInsecureRequestsForLoopbackAddr) {
            var appInfo = AppInfo.GetAppInfo();
            var isMobileRuntime = appInfo != null && appInfo.IsMobileRuntime;

            // when we mark servicecenter accessible as https only, we need to consider localhost requests as secure for scinstall to work
            if ((allowInsecureRequestsForLoopbackAddr || isMobileRuntime) && NetworkInterfaceUtils.IsLoopbackAddress(request.UserHostAddress)) {
                return true;
            }

            return RequestIsHttps(request);
        }


        // Returns the protocol for the current request, as seen in the browser.
        public static bool RequestIsHttps(HttpRequest request) {
            if (request.IsSecureConnection) {
                return true;
            }

            // Check if we have the special http to https header
            string httpToHttpsProxyHeader = Settings.Get(Settings.Configs.HTTPtoHTTPSproxyHeader);

            if (!httpToHttpsProxyHeader.IsEmpty()) {
                string[] headerParts = httpToHttpsProxyHeader.Split(new char[] { ':' }, 2);
                string requestHeaderValue = request.Headers[headerParts[0].Trim()];

                if (requestHeaderValue == null) {
                    return false;   // The header isn't present in the request
                } else if (headerParts.Length == 1) {
                    return true;    // The header is present and we didn't specify a value for it...
                } else {
                    // Check if the header value is the one we specified...
                    return requestHeaderValue.ToLowerInvariant().Trim() == headerParts[1].Trim();
                }
            }

            return false;
        }

        public static void AddNoCacheHeaders(HttpResponse response) {
            // see: http://stackoverflow.com/a/2068407
            response.AddHeader("Cache-Control", "no-cache, no-store, must-revalidate");	// HTTP 1.1
            response.AddHeader("Pragma", "no-cache"); // HTTP 1.0
            response.AddHeader("Expires", "0"); // Proxies
        }

        public static string GetURL(string url, BaseAppUtils appUtils, string overrideApplicationUrl) {
            string finalUrl = url;
            // Check if we have the special http to https header
            string httpToHttpsProxyHeader = Settings.Get(Settings.Configs.HTTPtoHTTPSproxyHeader);

            if (!httpToHttpsProxyHeader.IsEmpty() && !Uri.IsWellFormedUriString(url, UriKind.Absolute)) {
                var bookmarkableURI = new Uri(BuiltInFunction.GetBookmarkableURL());

                if (url.StartsWith("/")) {
                    finalUrl = bookmarkableURI.GetLeftPart(UriPartial.Authority) + url;
                } else if (appUtils != null) {
                    string applicationUrl = appUtils.getImagePath(/*internalAccess*/false, /*includeSessionIdIfNeeded*/false, overrideApplicationUrl);
                    finalUrl = bookmarkableURI.GetLeftPart(UriPartial.Authority) + applicationUrl + url;
                }
            }
            return finalUrl;
        }

        public static string GetRequestURL(HttpRequest request) {
            //the mapping of Request.Url was fixed to add queryString (to become equivalent to dotnet)
            // but this method is used in External Extensions that in Java already are considering that querystring is not returned and append it @ the end
            
            Uri requestUrl = request.Url;

            // Change the scheme of the request url to reflect the RequestIsSecure
            return (RequestIsHttps(request) ? "https" : "http") + requestUrl.ToString().Substring(requestUrl.Scheme.Length);
        }

        public static string CheckUriSecurity(HttpRequest request, string uri) {
            // DO NOT replace with one receiving an Uri .. the "new Uri(uri)" might change the uri
            if (RequestIsHttps(request) && uri.ToLower().StartsWith("http")) {
                return "https" + uri.Substring(uri.IndexOf(":"));
            }
            return uri;
        }

        public static Process LaunchProcess(string command, string commandParams, string path, ProcessPriorityClass priority, string username, string domain, string password) {
            return SystemProcess.Launch(command, commandParams, path, priority, username, domain, password).Process;
        }


        public static Process LaunchProcess(string command, string commandParams, string path, ProcessPriorityClass priority) {
            return SystemProcess.Launch(command, commandParams, path, priority).Process;
        }

        // launches a process
        public static Process LaunchProcess(string command, string commandParams, bool hidden, ProcessPriorityClass priority) {
            return SystemProcess.Launch(command, commandParams, hidden, priority).Process;
        }

        [Obsolete("Use LaunchProcess(String command, String commandParams, bool hidden, ProcessPriorityClass priority) instead.")]
        public static Process LaunchProcess(string command, string commandParams, bool hidden) {
            return SystemProcess.Launch(command, commandParams, hidden, ProcessPriorityClass.Normal).Process;
        }

        // waits for the end of a process maxTime time
        public static bool ProcessEnded(Process process, int maxTime) {
            return process.WaitForExit(maxTime);
        }

        public static string GetEspacePrettyNamePath(string eSpaceName, HeContext heContext) {
            if (heContext.OsISAPIFilter.IsEnabled) {
                string lCaseESpaceName = eSpaceName.ToLower();
                if (heContext.GetESpacePrettyNames.ContainsKey(lCaseESpaceName)) {
                    return (heContext.GetESpacePrettyNames[lCaseESpaceName]);
                }
            }
            return "/" + eSpaceName + "/";
        }

        public static List<string> GetPageRules(int eSpaceId, string PageName, HeContext heContext) {
            if (heContext.OsISAPIFilter.IsEnabled) {
                string lCasePageName = PageName.ToLower();
                if (heContext.GetPageRules(eSpaceId).ContainsKey(lCasePageName)) {
                    return heContext.GetPageRules(eSpaceId)[lCasePageName];
                }
                // Remove any flow prefix in the name and try again: WebFlow1.MyPage -> MyPage
                int NonPrefixedPos = lCasePageName.IndexOf('.');
                if (NonPrefixedPos != -1) {
                    lCasePageName = lCasePageName.Substring(NonPrefixedPos + 1);
                    if (heContext.GetPageRules(eSpaceId).ContainsKey(lCasePageName)) {
                        return heContext.GetPageRules(eSpaceId)[lCasePageName];
                    }
                }
            }
            return null;
        }

        public static string FixHostIPForIPV6(string host) {
            return (host.Contains(":") && !host.StartsWith("[")) ? "[" + host + "]" : host;
        }

        private static string GetRequestRealIPOldBehaviour(HttpRequest request) {
            string requestIp = "";
            requestIp = request.Headers.Get("X-Forwarded-For");
            if (requestIp != null && requestIp.IndexOf(",") > 0)
                requestIp = requestIp.Substring(0, requestIp.IndexOf(",")).Trim();
            else if (string.IsNullOrEmpty(requestIp) || requestIp.ToLower() == "unknown")
                requestIp = request.UserHostAddress;
            return requestIp;
        }

        public static string GetRequestRealIP(HttpRequest request) {
            //Both GetRequestIPAddress from OMLProcessor.xif and GetIP from HTTPRequestHandler.xif call this method
            //Lifetime and ServiceCenter use the action from OMLProcessor and Users.oml uses the one from HTTPRequestHandler

            string requestIp = "";

            if (Settings.GetBool(Settings.Configs.EnableTrustedProxies)) {
                if (IsFromTrustedProxy(request.UserHostAddress)) {
                    requestIp = GetTrustedAddressFromForwardHeader(request.Headers.Get("X-Forwarded-For"));
                }

                if (requestIp.IsNullOrEmpty()) {
                    return request.UserHostAddress;
                } else {
                    return requestIp;
                }
            } else {
                return GetRequestRealIPOldBehaviour(request);
            }
        }

        public static string GetTrustedAddressFromForwardHeader(string header) {
            if (header.IsNullOrEmpty()) {
                return null;
            }
            string requestIp = string.Empty;
            string[] headerAddresses = header.Split(',');
            Array.Reverse(headerAddresses);
            foreach (string headerAddress in headerAddresses) {
                string address = headerAddress.Trim();
                if (IsFromTrustedProxy(address)) {
                    continue;
                } else {
                    requestIp = address;
                    break;
                }
            }
            if (!requestIp.IsEmpty() && IPAddressValidation(requestIp)) {
                return requestIp;
            }
            return null;
        }

        public static bool IsFromTrustedProxy(string requestIPAddress) {
            IPAddress requestIp;

            if (!IPAddressValidation(requestIPAddress, out requestIp)) {
                return false;
            }

            var trustedProxyAddresses = TrustedProxyAddressRanges.GetValue();
            foreach (var range in trustedProxyAddresses) {
                if (range.Contains(requestIp)) {
                    return true;
                }
            }

            return false;
        }

        public static byte[] TryGetResourceBinary(string resource, string application) {
            return GetResourceBinary(resource, application, /*throwOnError*/false);
        }
        public static byte[] GetResourceBinary(string resource, string application) {
            return GetResourceBinary(resource, application, /*throwOnError*/true);
        }

        private static byte[] GetResourceBinary(string resource, string application, bool throwOnError) {
            try {
                return GetResourceBinaryInternal(resource, application, throwOnError);
            } catch (Exception e) {
                if (throwOnError) {
                    throw new InvalidOperationException("Could not access resource '{0}' in producer '{1}'. Make sure the reference is not outdated and both eSpaces are on the same Zone.".F(resource, application), e);
                }
                return null;
            }
        }

        private static byte[] GetResourceBinaryInternal(string resource, string application, bool throwOnError) {
            // Fetch from PTA if we're running inside one, on the owner of the resource. Otherwise get from owner's main area
            string filePath;
            if (AppInfo.GetAppInfo().eSpaceName == application) {
                filePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, resource);
            } else {
                filePath = Path.Combine(HttpContext.Current.Server.MapPath("/" + application), resource);
            }

            if (!throwOnError && !File.Exists(filePath)) {
                return null;
            }
            return File.ReadAllBytes(filePath);
        }

        private static readonly Dictionary<string, string> extensionsToMimeTypes = new Dictionary<string, string>() {
            { "bmp", "image/bmp" },
            { "gif", "image/gif" },
            { "jpg", "image/jpg" },
            { "jpeg", "image/jpeg" },
            { "png", "image/png" },
        };

        public static string GetMIMEType(string extension) {
            return extensionsToMimeTypes.GetValueOrDefault(extension) ?? string.Empty;
        }

        public static string GetMIMEType(byte[] bytes) {
            // see http://www.mikekunz.com/image_file_header.html  
            var bmp = Encoding.ASCII.GetBytes("BM");       // BMP
            var gif = Encoding.ASCII.GetBytes("GIF");      // GIF
            var png = new byte[] { 137, 80, 78, 71 };      // PNG
            var tiff = new byte[] { 73, 73, 42 };          // TIFF
            var tiff2 = new byte[] { 77, 77, 42 };         // TIFF
            var jpeg = new byte[] { 255, 216, 255, 224 };  // jpeg
            var jpeg2 = new byte[] { 255, 216, 255, 225 }; // jpeg canon

            if (bmp.SequenceEqual(bytes.Take(bmp.Length))) {
                return "image/bmp";
            }

            if (gif.SequenceEqual(bytes.Take(gif.Length))) {
                return "image/gif";
            }

            if (png.SequenceEqual(bytes.Take(png.Length))) {
                return "image/png";
            }

            if (tiff.SequenceEqual(bytes.Take(tiff.Length))) {
                return "image/tiff";
            }

            if (tiff2.SequenceEqual(bytes.Take(tiff2.Length))) {
                return "image/tiff";
            }

            if (jpeg.SequenceEqual(bytes.Take(jpeg.Length))) {
                return "image/jpeg";
            }

            if (jpeg2.SequenceEqual(bytes.Take(jpeg2.Length))) {
                return "image/jpeg";
            }

            return "application/octet-stream";
        }

        private static ICompilerContext compilerContext;

        public static ICompilerContext GetCompilerContext() {
            if (compilerContext == null) {
                compilerContext = new ICompilerContext(
                    Settings.Get(Settings.Configs.Sandbox_OperatingSandboxMode).ToLower() == "true",
                    Settings.Get(Settings.Configs.Sandbox_BoxKeyName));
            }
            return compilerContext;
        }

        static RuntimePlatformUtils() {
            ChangeDefaultEncoding(IsJava());
        }
        public static string WebPageExtension {
            get {
                return IsJava() ? ".jsf" : ".aspx";
            }
        }

        public static string GetAdministrationEmail() {
            string email = string.Empty;

            using (var tran = DatabaseAccess.ForSystemDatabase.GetReadOnlyTransaction()) {
                email = (string)DBRuntimePlatform.Instance.GetSitePropertyByName(tran, "AdministrationEmail", Constants.ServiceCenterName,
                    Constants.ServiceCenterName);
            }
            return email;
        }

        public static void SetupCurrentThreadCulture() {
            Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo("en-US");
            Thread.CurrentThread.CurrentUICulture = CultureInfo.GetCultureInfo("en-US");
        }

        internal static int GetCurrentDefaultTenantId() {
            var app = AppInfo.GetAppInfo();
            if (app != null) {
                using (var trans = DatabaseAccess.ForSystemDatabase.GetReadOnlyTransaction()) {
                    return DBRuntimePlatform.Instance.GetDefaultTenantIdByUserProviderEspaceKey(trans, app.UserProviderEspaceKeyAsKey, "-");
                }
            }
            return 0;
        }

        internal static bool IsApplicationEnabled(int eSpaceId) {
            using (var tran = DatabaseAccess.ForSystemDatabase.GetReadOnlyTransaction()) {
                return DBRuntimePlatform.Instance.GetApplicationEnabledForEspace(tran, eSpaceId);
            }
        }

        public static void ExecuteWithRetries(int maxRetries, Action actionToExecute) {
            ExecuteWithRetriesInfo(maxRetries, actionToExecute, (i, e) => { });
        }

        public static void ExecuteWithRetriesInfo(int maxRetries, Action actionToExecute, Action<int, Exception> logException) {
            Exception lastException = null;

            for (int i = 0; i < maxRetries; i++) {
                try {
                    lastException = null;
                    actionToExecute();
                } catch (Exception e) {
                    logException(i, e);
                    lastException = e;
                    continue;   // could be a temporary problem...
                }

                break;
            }

            if (lastException != null) {
                
                throw lastException;
            }
        }

        public static string GetWebReferenceEffectiveOrDefaultURL(string webrefSSKey, int eSpaceId) {
            bool isDefault;
            return GetWebReferenceEffectiveOrDefaultURL(webrefSSKey, eSpaceId, /*cacheValue*/true, out isDefault);
        }

        public static string GetWebReferenceEffectiveOrDefaultURL(string webrefSSKey, int eSpaceId, out bool isDefault) {
            return GetWebReferenceEffectiveOrDefaultURL(webrefSSKey, eSpaceId, /*cacheValue*/false, out isDefault);
        }

        private static string GetWebReferenceEffectiveOrDefaultURL(string webrefSSKey, int eSpaceId, bool cacheValue, out bool isDefault) {
            bool innerIsDefault = false;
            Func<string> fetchFromDb = () => {
                using (var tran = DatabaseAccess.ForSystemDatabase.GetReadOnlyTransaction()) {
                    using (var reader = DBRuntimePlatform.Instance.GetWebReferenceURLs(tran, webrefSSKey, eSpaceId)) {
                        if (reader.Read()) {
                            // get default url
                            var url = reader.SafeGet<string>("URL");
                            // get effective url
                            var effectiveUrl = reader.SafeGet<string>("Effective_URL");
                            if (effectiveUrl != null) {
                                // #484852 trim to convert oracle " " to ""
                                effectiveUrl = effectiveUrl.Trim();
                            }
                            if (effectiveUrl.IsEmpty()) {
                                innerIsDefault = true;
                                return url;
                            } else {
                                return effectiveUrl;
                            }
                        }
                        return string.Empty;
                    }
                }
            };


            if (cacheValue) {
                isDefault = false;
                return AppCache.GetESpaceCachedValue<string, string>(webrefSSKey, "WebReferenceURLCache", eSpaceId, dummy => fetchFromDb());
            } else {
                var result = fetchFromDb();
                isDefault = innerIsDefault;
                return result;
            }
        }

        public static WebReferenceConfiguration GetWebReferenceLoggingConfiguration(string webrefSSKey, int eSpaceId) {
            WebReferenceConfiguration configuration = new WebReferenceConfiguration();
            
            using (var tran = DatabaseAccess.ForSystemDatabase.GetReadOnlyTransaction()) {
                using (var reader = DBRuntimePlatform.Instance.GetWebReferenceLoggingConfiguration(tran, webrefSSKey, eSpaceId)) {
                    if (reader.Read()) {
                        var traceAll = reader.SafeGet<bool>("TRACEALL");
                        var traceErrors = reader.SafeGet<bool>("TRACEERRORS");

                        configuration = new WebReferenceConfiguration(traceErrors, traceAll);
                    }
                }
            }
            return configuration;
        }

        public const string EditRecordDefinedInParentScreen = "Parent-Screen";


        public static void LogSlowExtensionCall(DateTime startTime, string description) {
        }

        public static void SaveTemporaryAndroidDownload(string guid, string mimeType, DateTime expireDate, byte[] fileContent, string filename, string disposition) {

            using (var tran = DatabaseAccess.ForSystemDatabase.GetRequestTransaction()) {
                var hash = RuntimeCommon.Cryptography.SecureHashHelper.Hash(fileContent);
                DBRuntimePlatform.InsertTemporaryAndroidDownload(tran, guid, mimeType, expireDate, fileContent, hash, filename, disposition);
            }
        }

        public static bool GetTemporaryAndroidDownload(string guid, out string mimeType, out DateTime expireDate, out byte[] fileContent, out string filename, out string disposition) {

            mimeType = null;
            expireDate = DateTime.MinValue;
            fileContent = null;
            filename = null;
            disposition = null;

            using (var tran = DatabaseAccess.ForSystemDatabase.GetReadOnlyTransaction()) {
                using (var reader = DBRuntimePlatform.GetTemporaryAndroidDownload(tran, guid)) {
                    if (reader.Read()) {
                        mimeType = reader.SafeGet<string>("MIMETYPE");
                        expireDate = reader.SafeGet<DateTime>("EXPIRES");
                        fileContent = reader.SafeGet<byte[]>("CONTENT");
                        filename = reader.SafeGet<string>("FILENAME");
                        disposition = reader.SafeGet<string>("DISPOSITION");
                        return true;
                    }
                }
            }
            return false;
        }


        public static string GetDatabaseImagePath(string entityName, string attributeName, string idValue, string fileName) {
            string entityDetails = RC4CryptHelper.EncryptWithFixedKey(entityName + "/" + attributeName + "/" + idValue);
            entityDetails = entityDetails.Replace("+", "-").Replace("/", "_");    /* Replace invalid URL chars */
            return "_image" + WebPageExtension + "/" + entityDetails + "/" + fileName;
        }

        public static RequestTracer GetRequestTracer() {
            if (HttpContext.Current != null) {
                var context = (HeContext)HttpContext.Current.Items["osContext"];
                if (context != null) {
                    return context.RequestTracer;
                }
            }
            return null;
        }

        private static Dictionary<string, EspaceProperties> requestEventespaceProperties = new Dictionary<string, EspaceProperties>();

        private static object requestEventespacePropertiesLocker = new object();

        public static EspaceProperties GetRequestEventEspaceProperties(string moduleKey) {
            var app = AppInfo.GetAppInfo();
            if (app != null && app.eSpaceUID == moduleKey) {
                return app.Properties;
            }
            lock (requestEventespacePropertiesLocker) {
                EspaceProperties properties;

                if (!requestEventespaceProperties.TryGetValue(moduleKey, out properties)) {

                    properties = new EspaceProperties(moduleKey);

                    requestEventespaceProperties.Add(moduleKey, properties);
                }

                return properties;
            }
        }
    }

    // WARNING:
    // should you change any of these values
    // also check OutSystems.HubEdition.RuntimePlatform.Web.JavaScriptManager.clientScript
    // and change the hardcoded value there!
    public enum CacheInvalidationMangleDepth {
        None = 0,
        PlatformInserted = 10,
        UserCSS = 20,
        All = 1000
    }

    // WARNING: Needs to be sync'ed with Service Center!
    public enum PathRuleKind {
        PassThroughESpace = 1,
        PassThroughVDir = 2,
        ESpacePrettyName = 3,
        Custom = 4
    }

}