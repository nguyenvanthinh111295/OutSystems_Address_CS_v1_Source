/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Linq;
using System.Net;
using System.Net.Http.Formatting;
using System.Text;
using System.Web;
using System.Web.Http;
using OutSystems.HubEdition.RuntimePlatform;
using OutSystems.RESTService.Behaviors;
using OutSystems.RESTService.ErrorHandling;
using OutSystems.RESTService.Formatters;
using System.Net.Http;
using OutSystems.Internal.Db;

namespace OutSystems.RESTService.Controllers {
    public abstract partial class RestServiceApiController : ApiController {

        protected readonly IBehaviorsConfiguration BehaviorsConfiguration;

        public RestServiceApiController() {
            var config = (RestServiceControllerConfiguration)this.GetType().GetCustomAttributes(typeof(RestServiceControllerConfiguration), true).FirstOrDefault();
            if (config != null) {
                this.BehaviorsConfiguration = config;
            } else {
                this.BehaviorsConfiguration = new RestServiceControllerConfiguration();
            }
        }

        protected DefaultValuesBehavior DefaultValuesBehavior {
            get { return this.BehaviorsConfiguration.DefaultValuesBehavior; }
        }

        protected JsonMediaTypeFormatter JsonMediaTypeFormater {
            get {
                return CustomJsonMediaTypeFormatter.GetInstance(this.BehaviorsConfiguration);
            }
        }

        public void ValidateRequestSecurity() {
            var useSSL = BehaviorsConfiguration.HTTPSecurity == HTTPSecurity.SSL;
            if (useSSL || ShouldEnforceSecureRequests(AppInfo.GetAppInfo())) {
                if(!RuntimePlatformUtils.RequestIsSecure(HttpContext.Current.Request, !useSSL)) {
                    throw new ExposeRestException("HTTPS connection required.", HttpStatusCode.Forbidden);
                }
            }

            if (BehaviorsConfiguration.InternalAccessOnly) {
                if (!RuntimePlatformUtils.InternalAddressIdentification(HttpContext.Current.Request)) {
                    throw new ExposeRestException("Access Denied.", HttpStatusCode.Forbidden);
                }
            }
        }

        private static bool ShouldEnforceSecureRequests(AppInfo appInfo) {
            return appInfo != null && appInfo.IsForcingSecurityForIntegrations();
        }

        /// <summary>
        /// Parses an  Authorization Header that contains Basic Authentication and sets Username and Password decoded from Base64.
        /// </summary>
        /// <remarks>The Auth Header is obtained from the current HttpRequest.</remarks>
        /// <param name="originalHeader">The Basic Authentication Header. Format: basic base64(user:pass)</param>
        /// <param name="username">The username retreived from the header.</param>
        /// <param name="password">The password retreived from the header.</param>
        /// <exception cref="ExposeRestException">If no BasicAuth header is present or not well formated</exception>
        public void ParseBasicAuthHeader(out string username, out string password) {
            string basicAuthHeader = RestServiceHttpUtils.TryGetRequestHeader(this.Request, "Authorization");

            // No auth header, send challenge
            if (string.IsNullOrEmpty(basicAuthHeader)) {
                this.SetHeader("WWW-Authenticate", "Basic realm=\"" + this.Url.Request.RequestUri.Host + "\"");
                throw new ExposeRestException("Basic Authentication required.", HttpStatusCode.Unauthorized, /*isLoggable*/false);
            }

            if (!TryParseBasicToken(basicAuthHeader, out username, out password)) {
                throw new ExposeRestException("Authorization header not well formed.", HttpStatusCode.BadRequest);
            }
        }

        private bool TryParseBasicToken(string basicAuthHeader, out String username, out String password) {
            username = null;
            password = null;

            try {
                // Incorrect string format (should be Basic base64(user:pass) )
                if (!basicAuthHeader.Trim().StartsWith("basic ", StringComparison.InvariantCultureIgnoreCase)) {
                    return false;
                }

                string[] headerParts = basicAuthHeader.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                if (headerParts.Length != 2) {
                    return false;
                }

                // according to the spec, it's ISO-8859-1
                // however, not all browsers use this. Some use UTF-8.
                string decodedAuth = Base64Decode(headerParts[1], Encoding.GetEncoding("ISO-8859-1"));
                if (!decodedAuth.Contains(':')) {
                    return false;
                }

                string[] userAndPassword = decodedAuth.Split(':');
                if (userAndPassword.Length != 2) {
                    return false;
                }

                username = userAndPassword[0];
                password = userAndPassword[1];
                return true;

            } catch {
                return false;
            }
        }

        public string Base64Decode(string base64EncodedData, Encoding encodingFormat) {
            if (encodingFormat == null) {
                encodingFormat = Encoding.UTF8;
            }
            return encodingFormat.GetString(Convert.FromBase64String(base64EncodedData));
        }

        public virtual bool IsSwaggerRequest(string currentRoute) {
            return false;
        }

        protected IHttpActionResult SwaggerJson(String serviceName) {
            this.ValidateRequestSecurity();
            var stream = GetType().Assembly.GetManifestResourceStream(serviceName + "Swagger.json");
            if (stream != null) {
                HttpResponseMessage responseMessage = new HttpResponseMessage(RestServiceHttpUtils.GetCurrentStatusCode());
                responseMessage.Content = new StreamContent(stream, (int)((stream.Length > 256 || stream.Length == 0) ? 256 : stream.Length));
                responseMessage.Content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("application/json");
                responseMessage.Content.Headers.ContentType.CharSet = Encoding.UTF8.WebName;
                return this.ResponseMessage(responseMessage);
            }
            
            return this.GetResponseResult("Can't find or open file '" + serviceName + "Swagger.json'.");
        }

        protected IHttpActionResult SwaggerDoc(String serviceName) {
            if (!this.Request.RequestUri.AbsoluteUri.EndsWith("/")) {
                HttpResponseMessage response = Request.CreateResponse(System.Net.HttpStatusCode.MovedPermanently);
                response.Headers.Location = new Uri(this.Request.RequestUri.AbsoluteUri + "/");
                return this.ResponseMessage(response);
            }
            
            this.ValidateRequestSecurity();
            var stream = GetType().Assembly.GetManifestResourceStream("swagger-doc.html");
            if (stream != null) {
                HttpResponseMessage responseMessage = new HttpResponseMessage(RestServiceHttpUtils.GetCurrentStatusCode());
                responseMessage.Content = new StreamContent(stream, (int)((stream.Length > 256 || stream.Length == 0) ? 256 : stream.Length));
                responseMessage.Content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("text/html");
                responseMessage.Content.Headers.ContentType.CharSet = Encoding.UTF8.WebName;
                return this.ResponseMessage(responseMessage);
            }

            return this.GetResponseResult("Can't find or open file 'swagger-doc.html'.");
        }
    }

}
